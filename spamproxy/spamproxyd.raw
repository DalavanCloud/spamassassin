#!/usr/bin/perl

# Some configurable stuff here.  This may get offloaded to a file in the
# future.

$smarthost="localhost:10026";

# This file is based largely on example code bundled with MacGyver's
# Net::SMTP::Server kit, but with some additional stuff to use
# Mail::SpamAsssassin and a modified version of Net::SMTP::Server::Relay so
# then it becomes Net::SMTP::Server::SmartHost.  This way I can direct mail
# to a specific mailserver specified.  ::Relay does MX lookups which isn't
# what we want, but instead, reinject the message back into the system via
# an unfiltered version of SMTP server
#
# This was written with Postfix in mind, but nothing says you cannot use it
# for another MTA.  Be sure to read FILTER_README for a bit more background
# on how to integrate an SMTP-based filter (considered an "advanced" method).
#
# --Ian R. Justman <ianj@esper.net>, 11/21/2001

use Carp;
use Net::SMTP::Server;
use Net::SMTP::Server::Client;
use Mail::SpamAssassin::SMTP::SmartHost;
use Mail::SpamAssassin;
use Net::DNS;

my $spamtest = Mail::SpamAssassin->new();
$spamtest->compile_now();       # ensure all modules etc. are preloaded
$/ = "\n";                      # argh, Razor resets this!  Bad Razor!

# Set up the server.  Right now, this is in accordance to Postfix's
# filtering documentation.
#
# Since a vast majority of the SMTP code is based on MacGyver's sample code,
# I'll spare everyone those details here as that info is in his code. 
# Instead,  I'll be concentrating on the message-handling portion. --irj

$server = new Net::SMTP::Server('localhost', 10025) ||
  croak("Unable to handle client connection: $!\n");

print "server started on port 10025";

while($conn = $server->accept()) {
    my $client = new Net::SMTP::Server::Client($conn) ||
      croak("Unable to handle client connection: $!\n");

    # Process the client.  This command will block until
    # the connecting client completes the SMTP transaction.
    $client->process || next;

    # Mail::Audit wants an array of lines, while the server returns a huge
    # string.  Since I am unsure whether it needs to have the CR/LF pair for
    # each line for use with Razor, after splitting it, using the CR/LF
    # pairs as delimiters, I walk over the message again to re-add them.
    # Once the array is populated and tweaked, it is then handed to a new
    # Mail::Audit object.
    # --irj

    $message = $client->{MSG};
    @msg = split ("\r\n", $message);
    $arraycont = @msg; for(0..$arraycont) { $msg[$_] .= "\r\n"; }
    %args = (data => \@msg);
    $mail = Mail::Audit->new(%args);

    # At some point, I may also put some other code so I can go grab
    # preferences, e.g. via MySQL, e.g. scoring parameters, or even whether to
    # filter at all (hey, with Perl + MySQL, your imagination is the
    # limit).
    #
    # This is where the testing actually happens.  In this example, which I
    # have in an actual production environment (save the address), I have it
    # rewriting the message then forwarding to a collection account for
    # examination.  The addresses have been changed to protect the innocent.
    #
    # If the message is OK, we skip doing anything with the object and
    # instead, pass the original message to the smarthost code below.
    # --irj

    my $status = $spamtest->check($mail);
    if ($status->is_spam ()) {
        $status->rewrite_mail ();
        $message = join ("",$mail->header(),@{$mail->body()});
        @recipients = ("====CHANGEME====");
        $recips = \@recipients;
    } else {
        $recips = $client->{TO};
    }

    $status->finish();

    # Here is where we actually connect back into Postfix or wherever.  As
    # has been mentioned before, more detailed information on how to set
    # Postfix up to use an "advanced" filter setup, directly upon this
    # documentation this implementation is based.
    #
    # Here, we need to use a hacked version of Net::SMTP::Server::Relay to
    # make this work, which I will bundle in along with the script.  I made
    # no other modifications to the rest of the distribution (which is
    # required to make this work and is in CPAN).
    # --irj

    my $relay = new Mail::SpamAssassin::SMTP::SmartHost($client->{FROM},
                                                 $recips,
                                                 $message,
                                                 "$smarthost");
}


=head1 NAME

spamproxyd - mail filter to identify spam using text analysis

=head1 SYNOPSIS

=over

=item spamproxyd

=back

=head1 OPTIONS

=over 4

F<spamproxyd> currently has no options.

=back

=head1 DESCRIPTION

This is a prototype for an SMTP filter based on B<Mail::SpamAssassin>
(http://spamassassin.org, http://spamassassin.sourceforge.net).

This was originally written with Postfix's filering in mind, based on the
"advanced" example detailed in the FILTER_README file in the Postfix
distribution, but there's no reason why it couldn't be used with other
servers.

This script is just proof of concept right now; it may more than likely not
be usable in a larger-scale environment where there's high volumes of mail
being transferred.  However, it's currently good enough for a small-scale
environment, like the IRC network for which I serve as postmaster, along
with several other people I service on a small machine.

This script requires B<Mail::SpamAssassin> (see above) and B<Net::SMTP::Server>
(http://www.macgyver.org/software/perl/, plus it is also in CPAN).  You also
need a modified version of one of the modules in order to connect to a
specific SMTP server, which I include in the package.

Right now, this script has a few shortcomings:

1.  It only handles one SMTP transaction at a time.  I am considering
    integrating preforking code in to allow for more concurrency, like the
    code found in MSDW's smtpprox package.

2.  Configurability, configurability!  This is especially true if this will
    filter for multiple people whose needs may be quite different, including
    per-user weighting of the "suspicious stuff", white-lists, etc, and of
    course, whether to tag spam then deliver (if wanted), even whether to
    filter or not.

3.  What do YOU want? Who knows?  With Perl, your imagination's the limit. 

So far, I've managed to zap quite a bit of spam that'd normally go right
through the server.  With Vipul's Razor, this can go up quite a bit.  If
anyone has any ideas about Vipul's Razor and how I populate my arrays,
please let me know.

=head1 SEE ALSO

Mail::SpamAssassin(3)
Net::SMTP::Server(3)

=head1 AUTHOR

Ian R. Justman E<lt>ianj@esper.netE<gt>

=head1 CREDITS

Justin Mason for B<Mail::SpamAssassin>

Habeeb J. "MacGyver" Dihu for his B<Net::SMTP::Server> code

Special thanks go out to the crew at my usual IRC hangout, notably Barry
Hughes, Matti Koskimies, plus a number of others whom I may have not given
appropriate credit, but you still deserve it.  You've been a big help.  :)

=head1 PREREQUISITES

C<Mail::SpamAssassin>
C<Net::SMTP::Server>

=cut
