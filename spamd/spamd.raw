#!/usr/bin/perl -Tw

############################################################
# The code in this file is copyright 2001 by Craig Hughes  #
# It is licensed for use with the SpamAssassin distribution#
# under the terms of the Perl Artistic License, the text of#
# which is included as the file named "License"            #
############################################################

use lib '../lib';	# added by jm for use inside the distro
use strict;
use Socket;
use Carp;
use Mail::Audit;
use Mail::SpamAssassin;
my $spamtest = Mail::SpamAssassin->new({local_tests_only=>1});
global %resphash = (
    EX_OK => 0,
    EX_USAGE => 64, # command line usage error
    EX_DATAERR => 65, # data format error
    EX_NOINPUT => 66, # cannot open input
    EX_NOUSER => 67, # addressee unknown
    EX_NOHOST => 68, # host name unknown
    EX_UNAVAILABLE => 69, # service unavailable
    EX_SOFTWARE => 70, # internal software error
    EX_OSERR => 71, # system error (e.g., can't fork)
    EX_OSFILE => 72, # critical OS file missing
    EX_CANTCREAT => 73, # can't create (user) output file
    EX_IOERR => 74, # input/output error
    EX_TEMPFAIL => 75, # temp failure; user is invited to retry
    EX_PROTOCOL => 76, # remote error in protocol
    EX_NOPERM => 77, # permission denied
    EX_CONFIG => 78, # configuration error
);

sub spawn;  # forward declaration
sub logmsg { print "$0 $$: @_ at ", scalar localtime, "\n" }

my $port = shift || 22874;
my $proto = getprotobyname('tcp');

($port) = $port =~ /^(\d+)$/ or die "invalid port";

socket(Server, PF_INET, SOCK_STREAM, $proto)        || die "socket: $!";
setsockopt(Server,SOL_SOCKET,SO_REUSEADDR,pack("l", 1)) || die "setsockopt: $!";
bind(Server, sockaddr_in($port, INADDR_ANY))        || die "bind: $!";
listen(Server,SOMAXCONN)                            || die "listen: $!";

logmsg "server started on port $port";

my $waitedpid = 0;
my $paddr;

sub REAPER {
    $waitedpid = wait;
    $SIG{CHLD} = \&REAPER;  # loathe sysV
}

$SIG{CHLD} = \&REAPER;

for ( $waitedpid = 0;
      ($paddr = accept(Client,Server)) || $waitedpid;
      $waitedpid = 0, close Client)
{
    next if $waitedpid and not $paddr;

    spawn sub {
	$|=1; # always immediately flush output
	# First request lines off stream
	my $request;
	chomp($request = <STDIN>);

	my $resp = "EX_OK";
	# Now read in message
	my $mail = Mail::Audit->new();
	# Now use copy-on-writed (hopefully) SA object
	my $status = $spamtest->check($mail);
	$status->rewrite_mail; #if $status->is_spam;

	print "SPAMD/1.0 $resphash{$resp} $resp\r\n",$mail->header,"\n",(join '',@{$mail->body});

	$status->finish();	# added by jm to allow GC'ing
    };

}

sub spawn {
    my $coderef = shift;

    unless (@_ == 0 && $coderef && ref($coderef) eq 'CODE') {
	confess "usage: spawn CODEREF";
    }

    my $pid;
    if (!defined($pid = fork)) {
	logmsg "cannot fork: $!";
	return;
    } elsif ($pid) {
	return; # I'm the parent
    }
    # else I'm the child -- go spawn

    open(STDIN,  "<&Client")   || die "can't dup client to stdin";
    open(STDOUT, ">&Client")   || die "can't dup client to stdout";
    exit &$coderef();
}

=head1 NAME

spamd - daemonized version of spamassassin

=head1 SYNOPSIS

  spamd [port]

=head1 DESCRIPTION

The purpose of this program is to provide a daemonized version of the
spamassassin executable.  The goal is improving throughput performance for
automated mail checking.

This is intended to be used alongside C<spamc>, a fast, low-overhead C client
program.

See the README file in the C<spamd> directory of the SpamAssassin distribution
for more details.

=head1 SEE ALSO

C<spamc>
C<spamassassin>
C<Mail::SpamAssassin>

=head1 AUTHOR

Craig R Hughes E<lt>craig@hughes-family.orgE<gt>

=head1 PREREQUISITES

C<Mail::SpamAssassin>

=cut

