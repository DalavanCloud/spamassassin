#!/usr/bin/perl

use strict;
use Fcntl;

BEGIN { @AnyDBM_File::ISA = qw(DB_File GDBM_File NDBM_File SDBM_File); }
use AnyDBM_File;

# for the DB format...
use constant FORMAT_FLAG        => 0xc0;        # 11000000
use constant ONE_BYTE_FORMAT    => 0xc0;        # 11000000
use constant TWO_LONGS_FORMAT   => 0x00;        # 00000000

use constant ONE_BYTE_SSS       => 0x38;        # 00111000
use constant ONE_BYTE_HHH       => 0x07;        # 00000111

use vars qw{
    %h $k $v @DBNAMES
    $NSPAM_MAGIC_TOKEN $NHAM_MAGIC_TOKEN
    $opt_dbpath $opt_min_hits $opt_max_hits
    $robinson_x $robinson_s_dot_x 
  };

use Getopt::Long;
GetOptions("dbpath=s", "min-hits=i", "max-hits=i");

@DBNAMES = qw(toks probs);

$NSPAM_MAGIC_TOKEN = '**NSPAM';
$NHAM_MAGIC_TOKEN = '**NHAM';

use constant ROBINSON_S_CONSTANT => 0.30;
$robinson_x = 0.5;
$robinson_s_dot_x = ($robinson_x * ROBINSON_S_CONSTANT);

my $path = $opt_dbpath;
$path ||= $ENV{HOME}."/.spamassassin/bayes";

my $has_probs_db = 1;

foreach my $dbname (@DBNAMES) {
  my $name = $path.'_'.$dbname;
  my $db_var = 'db_'.$dbname;
  if (!tie %{$h{$db_var}}, "AnyDBM_File",$name, O_RDONLY,0600) {
    warn "Cannot open file $name: $!\n";
    if ($dbname eq 'probs') { $has_probs_db = 0; }
  }
}

my $dbformat = 'on-the-fly probs';
my $ns = $h{db_toks}->{$NSPAM_MAGIC_TOKEN};
my $nn = $h{db_toks}->{$NHAM_MAGIC_TOKEN};
if ($has_probs_db) {
  $dbformat = 'pre-computed probs';
  $ns ||= $h{db_probs}->{$NSPAM_MAGIC_TOKEN};	# older version
  $nn ||= $h{db_probs}->{$NHAM_MAGIC_TOKEN};
}
$ns ||= 0;
$nn ||= 0;

printf ("%3.3f %8d %8d   %s\n", 0.0, 0, 0,
			'non-token data: db format = '.$dbformat);
printf ("%3.3f %8d %8d   %s\n", 0.0, 0, $ns, 'non-token data: nspam');
printf ("%3.3f %8d %8d   %s\n", 0.0, 0, $nn, 'non-token data: nham');

my %seen = ();
my $prob;

if (!$has_probs_db) {
  $seen{$NSPAM_MAGIC_TOKEN} = $seen{$NHAM_MAGIC_TOKEN} = 1;
}

for my $key ( keys(%{$h{db_toks}}) ) {
  next if (exists $seen{$key});
  $seen{$key} = 1;

  my ($ts, $th) = tok_unpack ($h{db_toks}->{$key});
  $ts ||= 0;
  $th ||= 0;

  next if ($opt_min_hits && (($ts + $th) < $opt_min_hits));
  next if ($opt_max_hits && (($ts + $th) > $opt_max_hits));

  if ($has_probs_db) {
    $prob = $h{db_probs}->{$key};
    if (defined $prob) {
      $prob = unpack ('f', $prob);
    }
  } else {
    $prob = compute_prob_for_token ($ts, $th, $ns, $nn);
  }

  $prob ||= 0.5;
  printf ("%3.3f %8d %8d   %s\n", $prob, $ts, $th, $key);
}

foreach my $dbname (@DBNAMES) {
  my $name = $path.'_'.$dbname;
  my $db_var = 'db_'.$dbname;
  untie %{$h{$db_var}};
}

sub tok_unpack {
  my ($packed, $ts, $th) = unpack("CLL", $_[0] || 0);

  if (($packed & FORMAT_FLAG) == ONE_BYTE_FORMAT) {
    $ts = ($packed & ONE_BYTE_SSS) >> 3;
    $th = ($packed & ONE_BYTE_HHH);
  }
  # else use $ts and $th we just unpacked.

  return ($ts, $th);
}


sub compute_prob_for_token {
  my ($s, $n, $ns, $nn) = @_;

  return if ($s == 0 && $n == 0);
  my $ratios = ($s / $ns);
  my $ration = ($n / $nn);
  my $prob;
  if ($ratios == 0 && $ration == 0) {
    warn "oops? ratios == ration == 0";
    return 0.5;
  } else {
    $prob = ($ratios) / ($ration + $ratios);
  }

  my $robn = $s+$n;
  return ($robinson_s_dot_x + ($robn * $prob)) /
		(ROBINSON_S_CONSTANT + $robn);
}

