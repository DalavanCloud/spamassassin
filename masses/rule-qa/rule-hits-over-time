#!/usr/bin/perl -w
#
# rule-hits-over-time - produce graphs of rule hits over time, using gnuplot
#
# <@LICENSE>
# Copyright 2004 Apache Software Foundation
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# </@LICENSE>

use Getopt::Long;
use SDBM_File;
use GD;

use strict;
use warnings;
use Fcntl;

sub usage {
  die q{
usage: rule-hits-over-time [options] --rule rulename log1 [log2 ...]

  --rule=rulename       specify rule to map
  --period=secs         specify period (default: 1 day)
  --size_x=pixels       width of output graphs, in pixels (def: 800)
  --size_y=pixels       height of ONE of the output graphs, in pixels
                        (default: 400)
  --as_counts           Do not scale to a percentage of messages;
                        report absolute messages hit per time period
  --cgi                 CGI output, to stdout with HTTP headers
  --text                text output only
};
}

use vars qw(
        $opt_rule $opt_size_x $opt_size_y $opt_text $opt_cgi
        $opt_period $opt_as_counts
);

GetOptions(
        'rule=s',
        'size_x=i',
        'size_y=i',
        'text',
        'cgi',
        'as_counts',
        'period=i',
) or usage();

usage() unless $opt_rule;

# fix PATH for sucky Solaris compatibility.
# fix PATHs for sucky Solaris compatibility.
$ENV{PATH} .= ":/local/gnuplot-4.0.0/bin:/opt/sfw/bin";
$ENV{LD_LIBRARY_PATH} .= ":/local/gd-2.0.33/lib";

my $rule_re = qr/[, ]${opt_rule}[, ]/;

my $period = $opt_period || (24 * 60 * 60 * 3);

my $graph_x                         = $opt_size_x || 800;
my $graph_y                         = $opt_size_y || 400;
my $scale_to_total_volume           = ($opt_as_counts ? 0 : 1);

my $fname_counter = 1;
my %graph_png_data = ();

my %allbuckets = ();
my %allresults = ();
my @allfiles = ();

my $graph_data = [];

my $this_file_results;

my $lastbucket;
my $nextbucket;
my $seen_y;
my $seen_n;

# my $tmpdir = "/tmp/rulehits.tmp";   # static for debugging
my $tmpdir = "/tmp/rulehits.$$";

mkdir ($tmpdir) or die "collided on $tmpdir";

my $outdir = ".";
if ($opt_cgi) {
  $outdir = $tmpdir;
}

my $file_sets = [ ];    # split into ham and spam
$file_sets = [ [ 'TITLE:hits in spam' ], [ 'TITLE:hits in ham' ] ];

foreach my $file (@ARGV) {
  if ($file =~ /\bham\b/) {
    push @{$file_sets->[1]}, $file;
  } else {
    push @{$file_sets->[0]}, $file;
  }
}

foreach my $set (@{$file_sets}) {
  @allfiles = ();
  %allbuckets = ();
  %allresults = ();

  my $settitle = '';
  if ($set->[0] =~ /^TITLE:(.*)$/) {
    $settitle = $1; shift(@{$set});
  }

  create_gp("$opt_rule $settitle");

  foreach my $file (@{$set}) {
    if (!$opt_text) {
      my $title = $file;
      $title =~ s/^.*\///;
    }
    push (@allfiles, $file);

    if (0) {
      # use an on-disk file to avoid massive VM usage for this hash
      # on huge datasets
      unlink("graph.tmp.dir");
      unlink("graph.tmp.pag");
      tie (%{$allresults{$file}}, 'SDBM_File', 'graph.tmp', O_RDWR|O_CREAT, 0600)
            or die "tie failed: $!";
    }
    else {
      %{$allresults{$file}} = ();
    }

    $this_file_results = $allresults{$file};
    read_logs($file);

    $graph_data = [];
    summarise();
  }

  plot_gp();
}

my $format = "gif";

{
  my $both = GD::Image->new($graph_x, 15 + ($graph_y * 2));
  my $file01 = GD::Image->newFromPngData($graph_png_data{"file01"}, 1);
  my $file02 = GD::Image->newFromPngData($graph_png_data{"file02"}, 1);

  # I thought this might work around the "black background" issue,
  # but it doesn't :(
  # my $white = $both->colorAllocate(255,255,255);
  # $both->filledRectangle(0, 0, $graph_x, 15 + ($graph_y * 2), $white);

  $both->copy($file01, 0, 5, 0, 0, $graph_x-1, $graph_y-1);
  $both->copy($file02, 0, 10 + $graph_y, 0, 0, $graph_x-1, $graph_y-1);

  # $both->copyResampled($file01, 0, 5, 0, 0,
  #            $graph_x/2, $graph_y/2, $graph_x-1, $graph_y-1);
  # $both->copyResampled($file02, 0, 10 + $graph_y, 0, 0,
  #            $graph_x/2, $graph_y/2, $graph_x-1, $graph_y-1);

  if ($opt_cgi) {
    use CGI qw(:standard);
    print header("image/$format"); binmode STDOUT;
    print STDOUT $both->$format();
  }
  else {
    open(IMG, ">both.$format") or die $!; binmode IMG;
    print IMG $both->$format();
    close IMG;
  }

  $both->gif();
}

unlink(<$tmpdir/*.*>); rmdir $tmpdir;

exit;

sub summarise {
  foreach my $bucket (sort keys %allbuckets) {
    my $total_n = 0;
    my @cols = ();
    foreach my $file (@allfiles) {
      my $sy = $allresults{$file}->{"y".$bucket};
      my $sn = $allresults{$file}->{"n".$bucket};

      if (!defined $sy && !defined $sn) {
        $sn = $sy = -1;
      } elsif (!defined $sy || !defined $sn) {
        # assert: enforce both < 0, if either is
        warn "oops? sy=$sy sn=$sn, should be both < 0";
        $sn = $sy = -1;
      }

      if ($scale_to_total_volume) {
        if ($sy >= 0) {
          my $frac = $sy / (($sy + $sn) || 0.0001);
          push @cols, ($frac * 100.0);
        }
        else {
          push @cols, -1;
        }
        $total_n = 100;
      }
      else {
        $total_n += $sn;
        push (@cols, $sy);
      }
    }

    if ($scale_to_total_volume) {
      @cols = ($bucket, @cols);     # total_n is always "100"
    } else {
      @cols = ($bucket, $total_n, @cols);
    }

    if ($opt_text) {
      print join(' ',@cols)."\n";
    }
    else {
      push (@{$graph_data}, \@cols);
    }
  }
}


sub read_logs {
  my $file = shift;

  $lastbucket = undef;
  $nextbucket = undef;
  $seen_y = 0;
  $seen_n = 0;

  if ($file =~ /\.gz$/) {
    open (IN, "gunzip -cd '$file'|") or die "cannot gunzip $file";
  } else {
    open (IN, "<$file") or die "cannot read $file";
  }

  while (<IN>) {
    next if /^#/;

    my $t;
    /\btime=(\d+),/ and $t = $1;
    next unless $t;

    my $found = ($_ =~ $rule_re);
    
    if (!defined $lastbucket) {
      $lastbucket = $t - ($t % $period);
      $nextbucket = $lastbucket + $period;
    }

    if ($t < $nextbucket) {
      if ($found) {
        $seen_y++;
      } else {
        $seen_n++;
      }
    }
    else {
      while ($t >= $nextbucket) {
        completeline();
        $lastbucket = $nextbucket;
        $nextbucket += $period;
      }
    }
  }
  close IN;
  completeline();
}

sub completeline {
  return unless ($lastbucket);
  $allbuckets{$lastbucket} = undef;
  $this_file_results->{"y".$lastbucket} = $seen_y; $seen_y = 0;
  $this_file_results->{"n".$lastbucket} = $seen_n; $seen_n = 0;
}

sub create_gp {
  my $title = shift;

  my $mailtype = 'mail';
  if ($title =~ /\b(ham|spam)\b/) { $mailtype = $1; }

  my $y_label = ($scale_to_total_volume ?
            "\%age of $mailtype in period" : "Num $mailtype messages in period");

  open (GP, "| gnuplot - > $tmpdir/gp.log 2>&1") or die "cannot run gnuplot";

  # eye-candy
  my $niceperiod = "$period secs";
  if ($period % (24*60*60) == 0) {
    $niceperiod = ($period / (24*60*60))." days";
  }

  # (NOTE: -1% hitrate means no data for that time period)'
  print GP qq{

    set xlabel 'Time, in blocks of $niceperiod'
    set ylabel '$y_label'

    set terminal png small \\
        interlace size $graph_x,$graph_y \\
        xffffff x444444 x33cc00 \\
        xff3300 x0000cc x99cc00 xff9900 \\
        xcccc00 x333333 x999999 x9500d3

    set out '$tmpdir/out.png'

    set grid back xtics ytics

    set xdata time
    set timefmt "%Y-%m-%d"
    set title "$title"

    set key left top Left nobox

  };
}

sub fmt_time_t {
  my $tt = shift;
  use POSIX qw(strftime);
  return strftime "%Y-%m-%d", gmtime($tt);
}

sub plot_gp {
  if (!$opt_text)
  {
    open (DATA, ">$tmpdir/plot.data") or die;
    foreach my $line (@{$graph_data}) {
      my $tt = shift @$line;
      print DATA fmt_time_t($tt)," ",join(' ', @$line),"\n";
    }
    close DATA or die;

    my @plot = ();
    foreach my $i (0 .. (scalar @allfiles - 1)) {
      my $legend = filename_to_legend ($allfiles[$i]);
      my $style = $i+1;
      my $col = $i+2;

      push @plot,
        qq{ '$tmpdir/plot.data' using }.

            # to plot "undefined" values as 0
            # qq{ 1:(\$$col >= 0 ? \$$col : 0) }.
            # as -1
            # qq{ 1:(\$$col >= 0 ? \$$col : -1) }.
            # to not plot "undefined" values at all (linespoints rec'd)
            qq{ 1:(\$$col >= 0 ? \$$col : 1/0) }.

            # qq{ with lines lt $style }.
            qq{ with linespoints lt $style pt $style }.

            qq{ title '$legend' };

      push @plot,
        qq{ '$tmpdir/plot.data' using }.
            qq{ 1:(\$$col >= 0 ? \$$col : 1/0) }.
            qq{ smooth bezier }.
            qq{ with lines lt $style lw 3 }.
            qq{ title '' };

    }

    print GP "plot ",join(", ", @plot), "\n";
    close GP;

    my $graphname = sprintf("file%02d", $fname_counter++);
    $graph_png_data{$graphname} = readfile("$tmpdir/out.png");
  }
}

sub readfile {
  open (IN, "<$_[0]") or die "cannot read $_[0]";
  binmode IN;
  my $str = join('',<IN>);
  close IN;
  return $str;
}

sub filename_to_legend {
  my $f = shift;

  $f =~ s/^.*\///;
  $f =~ s/LOGS\.all-//;
  $f =~ s/\.log\.\S+$//;
  return $f;
}
