#!/usr/bin/perl
# usage:
# ./lint-rules-from-freqs < freqs > badtests

print "BAD TESTS REPORT\n";
print "\nRule file syntax issues:\n\n";
readrules();
lintrules();

while (<>) {
  if (!/^\s*([\d\.]+)/) {
    $output{'a_header'} = $_; next;
  }

  my $badrule;
  my ($overall, $spam, $nons, $sn, $score, $name) = split (' ');
  next unless ($name =~ /\S/);

  my $tf = $tflags{$name};
  next if ($tf =~ /net/);

  if ($overall == 0.0) {
    $badrule = 'no matches';

  } else {
    if ($score < 0.0) {
      # negative score with more spams than nonspams? bad rule.
      if ($tf !~ /nice/ && $sn > 0.5 && $score < 0.5) { $badrule = 'non-nice but -ve score'; }

      if ($tf =~ /nice/ && $sn > 0.5 && $score < 0.5) { $badrule = 'fn'; }

      # low number of matches overall
      if ($nons < 0.05) { $badrule ||= ''; $badrule .= ', low matches'; }

    } elsif ($score > 0.0) {
      # positive score with more nonspams than spams? bad.
      if ($tf =~ /nice/ && $sn < 0.5 && $score > 0.5) { $badrule = 'nice but +ve score'; }

      if ($tf !~ /nice/ && $sn < 0.5 && $score > 0.5) { $badrule = 'fp'; }

      # low number of matches overall
      if ($spam < 0.05) { $badrule ||= ''; $badrule .= ', low matches'; }

    } elsif ($score == 0.0) {
      $badrule = 'score is 0';
    }
  }

  if (defined $badrule) {
    $badrule =~ s/^, //; chomp;
    $output{$badrule} .= $_ . " ($badrule)\n";
  }
}

# do all but 'no/low matches' first
print "\nHigh-priority issues:\n\n";
foreach my $badness (sort keys %output) {
  next if ($badness eq 'no matches');
  next if ($badness eq 'low matches');
  print $output{$badness};
  delete $output{$badness};
}

# now go back and do the other 2 (if they're there)
print "\nLow-priority issues:\n\n";
foreach my $badness (sort keys %output) {
  next unless defined ($output{$badness});
  print $output{$badness};
  delete $output{$badness};
}
exit;

sub readrules {
  my @files = <../rules/[0-9]*.cf>;
  my $file;
  @rulesfound = ();
  foreach $file (@files) {
    open (IN, "<$file");
    while (<IN>) {
      s/#.*$//g; s/^\s+//; s/\s+$//; next if /^$/;
      s/^lang\s+\S+\s+//;

      if (/^(header|rawbody|body|full|uri)\s+(\S+)\s+/) {
        push (@rulesfound, $2);
        $rulefile{$2} ||= $file;
        $scorefile{$1} = $file;
        $score{$2} ||= 1.0;
        $tflags{$2} ||= '';
        $descfile{$2} ||= $file;       # a rule with no score or desc is OK
      } elsif (/^describe\s+(\S+)\s+/) {
        push (@rulesfound, $1);
        $descfile{$1} = $file;
      } elsif (/^tflags\s+(\S+)\s+(.+)$/) {
        push (@rulesfound, $1);
        $tflags{$1} = $2;
        $tflagsfile{$1} = $file;
      } elsif (/^score\s+(\S+)\s+(.+)$/) {
        push (@rulesfound, $1);
        $scorefile{$1} = $file;
        $score{$1} = $2;
      } elsif (/^(clear-report-template|clear-spamtrap-template|report|spamtrap|
                clear-terse-report-template|terse-report|
                required_hits|ok_locales|ok_languages|test|lang|
                spamphrase|whitelist_from
                )/x) {
        next;
      } else {
        print "warning: unknown rule in $file: $_\n";
      }
    }
    close IN;
  }
}

sub lintrules {
  foreach my $rule (@rulesfound) {
    if (defined $descfile{$rule} && !defined ($rulefile{$rule})) {
      print "warning: $rule has description, but no rule: $descfile{$rule}\n";
    }
    if (defined $score{$rule} && !defined ($rulefile{$rule})) {
      print "warning: $rule has score, but no rule: $scorefile{$rule}\n";
    }
  }
}

