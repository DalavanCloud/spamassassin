#!/usr/bin/perl

sub usage {
  die "
lint-rules-from-freqs: perform 'lint' testing on SpamAssassin rules and scores

usage: ./lint-rules-from-freqs [-f falsefreqs] < freqs > badtests

This analyzes SpamAssassin tests, based on the hit frequencies and S/O ratios
from a mass-check logfile pair.

The 'freqs' argument is the frequency of hits in all messages ('hit-frequencies
-x -p' output).

The 'falsefreqs' argument is frequencies of hits in false-positives and
false-negatives only ('hit-frequencies -x -p -f' output).

";
}

my $opt_falsefreqs;
while ($#ARGV >= 0) {
  $_ = shift @ARGV;
  if (/^-f/) { $_ = shift @ARGV; $opt_falsefreqs = $_; }
  else { usage(); }
}

print "BAD TESTS REPORT\n";
print "\nRule file syntax issues:\n\n";
readrules();
lintrules();

if ($opt_falsefreqs) {
  open (FALSE, "<$opt_falsefreqs");
  while (<FALSE>) {
    if (!/^\s*([\d\.]+)/) {
      my ($overall, $spam, $nons, $so, $score, $name) = split (' ');
      next unless ($name =~ /\S/);
      $falsefreqs_spam{$name} = $spam;
      $falsefreqs_nons{$name} = $nons;
      $falsefreqs_so{$name} = $so;
    }
  }
  close FALSE;
}

while (<>) {
  if (!/^\s*([\d\.]+)/) {
    $output{'a_header'} = $_; next;
  }

  my $badrule;
  my ($overall, $spam, $nons, $so, $score, $name) = split (' ');
  next unless ($name =~ /\S/);

  my $ffspam = $falsefreqs_spam{$name};
  my $ffnons = $falsefreqs_nons{$name};
  my $ffso = $falsefreqs_so{$name};

  my $tf = $tflags{$name};
  next if ($tf =~ /net/);

  if ($overall == 0.0 && $spam == 0.0 && $nons == 0.0) {        # sanity!
    $badrule = 'no matches';

  } else {
    if ($score < 0.0) {
      # negative score with more spams than nonspams? bad rule.
      if ($tf !~ /nice/ && $so > 0.5 && $score < 0.5) {
        $badrule = 'non-nice but -ve score';
      }

      if ($tf =~ /nice/ && $so > 0.5 && $score < 0.5) {
        if ($ffso < 0.5) {
          $badrule = 'fn';
        } else {
          # ignore, the FNs are overridden by other tests so it doesn't
          # affect the overall results.
        }
      }

      # low number of matches overall
      if ($nons < 0.05) { $badrule ||= ''; $badrule .= ', low matches'; }

    } elsif ($score > 0.0) {
      # positive score with more nonspams than spams? bad.
      if ($tf =~ /nice/ && $so < 0.5 && $score > 0.5) {
        $badrule = 'nice but +ve score';
      }

      if ($tf !~ /nice/ && $so < 0.5 && $score > 0.5) {
        if ($ffso > 0.5) {
          $badrule = 'fp';
        } else {
          # ignore, the FPs are overridden by other tests so it doesn't
          # affect the overall results.
        }
      }

      # low number of matches overall
      if ($spam < 0.05) { $badrule ||= ''; $badrule .= ', low matches'; }

    } elsif ($score == 0.0) {
      $badrule = 'score is 0';
    }
  }

  if (defined $badrule) {
    $badrule =~ s/^, //; chomp;
    $output{$badrule} .= $_ . " ($badrule)\n";
  }
}

# do all but 'no/low matches' first
print "\nHigh-priority issues:\n\n";
foreach my $badness (sort keys %output) {
  next if ($badness eq 'no matches');
  next if ($badness eq 'low matches');
  print $output{$badness};
  delete $output{$badness};
}

# now go back and do the other 2 (if they're there)
print "\nLow-priority issues:\n\n";
foreach my $badness (sort keys %output) {
  next unless defined ($output{$badness});
  print $output{$badness};
  delete $output{$badness};
}
exit;

sub readrules {
  my @files = <../rules/[0-9]*.cf>;
  my $file;
  @rulesfound = ();
  foreach $file (@files) {
    open (IN, "<$file");
    while (<IN>) {
      s/#.*$//g; s/^\s+//; s/\s+$//; next if /^$/;
      s/^lang\s+\S+\s+//;

      if (/^(header|rawbody|body|full|uri)\s+(\S+)\s+/) {
        push (@rulesfound, $2);
        $rulefile{$2} ||= $file;
        $scorefile{$1} = $file;
        $score{$2} ||= 1.0;
        $tflags{$2} ||= '';
        $descfile{$2} ||= $file;       # a rule with no score or desc is OK
      } elsif (/^describe\s+(\S+)\s+/) {
        push (@rulesfound, $1);
        $descfile{$1} = $file;
      } elsif (/^tflags\s+(\S+)\s+(.+)$/) {
        push (@rulesfound, $1);
        $tflags{$1} = $2;
        $tflagsfile{$1} = $file;
      } elsif (/^score\s+(\S+)\s+(.+)$/) {
        push (@rulesfound, $1);
        $scorefile{$1} = $file;
        $score{$1} = $2;
      } elsif (/^(clear-report-template|clear-spamtrap-template|report|spamtrap|
                clear-terse-report-template|terse-report|
                required_hits|ok_locales|ok_languages|test|lang|
                spamphrase|whitelist_from
                )/x) {
        next;
      } else {
        print "warning: unknown rule in $file: $_\n";
      }
    }
    close IN;
  }
}

sub lintrules {
  my %warned = ();
  foreach my $rule (@rulesfound) {
    if (defined $descfile{$rule} && !defined ($rulefile{$rule})) {
      next if $warned{"desc_no_rule_".$descfile{$rule}};
      print "warning: $rule has description, but no rule: $descfile{$rule}\n";
      $warned{"desc_no_rule_".$descfile{$rule}} = 1;
    }
    if (defined $score{$rule} && !defined ($rulefile{$rule})) {
      next if $warned{"score_no_rule_".$descfile{$rule}};
      print "warning: $rule has score, but no rule: $scorefile{$rule}\n";
      $warned{"score_no_rule_".$descfile{$rule}} = 1;
    }
  }
}

