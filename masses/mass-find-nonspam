#!/usr/bin/perl -w
#
# used to clean out spamtraps.

my $killfile_message_ids = qr{(?:
    <\d\d\d\d\S+\@dev\.lifetimetv\.com>
    |<\d+\.\S+\@fmail..\.real-net\.net>
    |<3D53A59C000A4029\@mta3n\.bluewin\.ch>
    |<\S+JavaMail\._accucast\@ecacmail01\.hsn\.com>
    |<CA-.*\@cert\.org>
)}x;

my $killfile_receiveds = qr{(?:
    from\s\S+\s\S+\sby\s(?:anclsmtp\d\d|myfamlsmtp\d\d)\.myfamily\.com
    |for :include:\S+/MapQuest/
    |for <spamistehsuk\@spamtraps\.taint\.org>          # unreliable
    |for <postmaster_neto.net\@spamtraps\.taint\.org>   # unreliable
    |for <fortress\S*\@shangri-la\.dropbear\.id\.au>
    |by mailstrom\.vmadmin\.com \(\S+\) with SMTP id 
    |by outgoing\.securityfocus\.com .Postfix.
    |envelope-from security-advisories\@freebsd\.org
    |envelope-from owner-announce\@hq\.lp\.org
    |from abv-sfo\S+\.CNET\.COM
    |for :include:\S+/MapQuest/
    |from bounce\.winxpnews\.com
    |\(envelope-from divx-return-\S+\@lists\.divx\.com\)
)}x;

my $killfile_froms = qr{(?:
    <listsupport\@internet\.com>
    |<journal\@wrox\.com>
    |<burpeeseed\@List\.burpee\.com>
    |<preferredcustomer\@photoworks\.com>
    |<proedigitaldigest\@proe\.com>
    |<subscriptions\@mcafee\.com>
    |<news\@real-net\.net>
    |<Online.*\@newsletter\.online\.com>
    |<no-reply\@no-more-viruses-please\.com>
    |<Joke-Of-The-Day-return-.*\@mta03\.optamail\.com>
    |<Cooking\.com\.\S+\@mail\.cooking\.com>
    |<cio\@UPDATE\.CIO\.COM>
    |<DirectTV\S+\@vmadmin\.com>
    |<\S+\@icelandair\.is>
    |<\S+\@lists\.techtarget\.com>
    |<gcn\@eletters\.gcn\.com>
    |newsletter\@rp-online\.de
)}x;

###########################################################################

use lib "lib";
use lib "../lib";
use Mail::ArchiveIterator;
use Mail::SpamAssassin::NoMailAudit;

# flush buffer immediately so if mass-check fails or stops we don't get a corrupt line
$|++;

my $iter = new Mail::ArchiveIterator ({
  });

$iter->set_function (\&wanted);
$iter->run (@ARGV);

#foreach my $from (sort {$count{$b} <=> $count{$a}} keys %count) {
#print "$count{$from}   $from $lastsubject{$from}  $lastid{$from}\n";
#}
exit;

###########################################################################

sub get_or_empty {
  my ($ma, $hdr) = @_;
  my $str = $ma->get_header ($hdr); $str ||= ''; return $str;
}

sub wanted {
  my ($id, $dataref) = @_;

  my $ma = Mail::SpamAssassin::NoMailAudit->new ('data' => $dataref);
  my $from = $ma->get_header ("From");
  return unless defined($from);

  if ($from =~ /${killfile_froms}/o
    || get_or_empty($ma,"Message-Id") =~ /${killfile_message_ids}/o
    || get_or_empty($ma,"Received") =~ /${killfile_receiveds}/)
  {
    print "$id\n";
  }

  #chomp $from;
  #$count{$from}++;
  #chomp ($lastsubject{$from} = $ma->get_header("Subject"));
  #chomp ($lastid{$from} = $id);
}

