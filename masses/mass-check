#!/usr/bin/perl

use lib "../lib";
use Mail::Internet;
use Mail::SpamAssassin;

$cffile = '../spamassassin.cf';
if (-f "spamassassin.cf") { $cffile = "spamassassin.cf"; }

if (defined $ARGV[0] && $ARGV[0] eq '-c') {
  shift; $cffile = $ARGV[0]; shift;
}

if (defined $ARGV[0] && $ARGV[0] eq '-ms') {
  shift; find_missed('spam.log');
}

if (defined $ARGV[0] && $ARGV[0] eq '-mn') {
  shift; find_missed('nonspam.log');
}

my $FORK = 0;
if (defined $ARGV[0] && $ARGV[0] eq '-f') { $FORK = 1; }

sub sortbynum {
  $a =~ m,\/(\d+).*$,; my $anum = $1;
  $b =~ m,\/(\d+).*$,; my $bnum = $1;
  ($anum <=> $bnum);
}

$spamtest = new Mail::SpamAssassin ({
  'rules_filename'      => $cffile,
  'userprefs_filename'  => "../spamassassin.prefs",
  'local_tests_only'    => 1
});
$spamtest->compile_now();

my $count = 0;

foreach my $folder (@ARGV) {
  if ($folder =~ /.tar$/)
  {
      # it's an MH or Cyrus folder in a tar file
      use Archive::Tar;
      mass_check_mh_tar_file($folder);
  }
  elsif (-d $folder &&
  	(-f "$folder/1" || -f "$folder/1.gz" || -f "$folder/cyrus.index"))
  {
    # it's an MH folder or a Cyrus mailbox
    mass_check_mh_folder($folder);

  } elsif (-f $folder) {
    mass_check_mailbox($folder);
  }
}

sub mass_check_mh_tar_file {
  my $filename = shift;
  my $tar = Archive::Tar->new();
  $tar->read($filename);
  my @files = $tar->list_files(['name']);
  foreach my $mail (@files) {
      next if $mail =~ m#/$# or $mail =~ /cyrus\.(index|header|cache)/;
      my $msg_data = $tar->get_content($mail);
      my @msg = split("\r\n",$tar->get_content($mail));
      my $ma = Mail::Audit->new(data => \@msg);
      $mail =~ s/\s/_/g;
      docheck ($mail, $ma);
  }
}

sub mass_check_mh_folder {
  my $folder = shift;
  my @files = <$folder/[0-9]*>;
  foreach my $mail (sort sortbynum @files) {
    if ($mail =~ /\.gz$/) {
      open (STDIN, "gunzip -cd $mail |") or warn "gunzip $mail failed: $@";
    } elsif ($mail =~ /\.bz2$/) {
      open (STDIN, "bzip2 -cd $mail |") or warn "bunzip2 $mail failed: $@";
    } else {
      open (STDIN, "<$mail") or warn "open $mail failed: $@";
    }
    my $ma = Mail::Audit->new();
    docheck ($mail, $ma);
  }
}

sub mass_check_mailbox {
  my $folder = shift;

  if ($folder =~ /\.gz$/) {
    open (MBOX, "gunzip -cd $folder |") or warn "gunzip $folder failed: $@";
  } elsif ($folder =~ /\.bz2$/) {
    open (MBOX, "bzip2 -cd $folder |") or warn "bunzip2 $folder failed: $@";
  } else {
    open (MBOX, "<$folder") or warn "open $folder failed: $@";
  }
  while (<MBOX>) { /^From \S+ +... ... / and last; }

  while (!eof MBOX) {
    my @msg = ();
    my $msgid = undef;
    $count++;

    while (<MBOX>) {
      /^Message-[Ii][Dd]: (.*)\s*$/ and $msgid = $1;

      if (/^$/) {
	if (!defined ($msgid)) {
	  $msgid = "<$count\@no_msgid_in_msg.taint.org>";
	  push (@msg, "Message-Id: $msgid\n");
	}
      }

      /^From \S+ +... ... / and last;
      push (@msg, $_);
    }

    # switch to a fork-based model to save RAM
    if ($FORK && fork()) { wait; next; }

    $msgid = "$folder:$msgid";		# so we can find it again
    $msgid =~ s/\s/_/gs;	# make safe

    my $ma = Mail::Audit->new('data' => \@msg);
    docheck ($msgid, $ma);

    if ($FORK) { exit; }
  }
  close MBOX;
}

sub docheck {
  my $id = shift;
  my $ma = shift;

  $ma->{noexit} = 1;
  my $status = $spamtest->check ($ma);
  $status->rewrite_mail ();

  $_ = $ma->get ("X-Spam-Status");
  /^(\S+), hits=(\S+) required=\S+ tests=(.+)\s*$/s;

  my $yorn = $status->is_spam();
  my $hits = $status->get_hits();
  my $tests = $status->get_names_of_tests_hit();
  $status->finish();

  undef $ma;		# clean 'em up
  undef $status;

  printf "%s %2d %s %s\n",
		    ($yorn ? 'Y' : '.'),
		    $hits, $id, $tests;
}


sub find_missed {
  my $file = shift;

  my $threshold = 5;

  my $shouldbespam = 1;
  if ($file =~ /nonspam/) { $shouldbespam = 0; }

  my $scores = readscores();

  open (IN, "<$file");
  while (<IN>) {
    /^.\s+\d+\s+(\S+)\s*/ or next;
    my $id = $1;
    my $score = 0.0;

    $_ = $'; s/,,+/,/g; s/^\s+//; s/\s+$//;
    foreach my $tst (split (/,/, $_)) {
      next if ($tst eq '');
      if (!defined $scores->{$tst}) {
	warn "unknown test in $file, ignored: $tst\n";
	next;
      }
      $score += $scores->{$tst};
    }

    if ($shouldbespam && $score < $threshold) {
      found_missed ($score, $id, $_);
    } elsif (!$shouldbespam && $score > $threshold) {
      found_missed ($score, $id, $_);
    }
  } 
  close IN;
}

sub readscores {
  my $scores = { };

  print "Reading scores from \"$cffile\"...\n";
  open (IN, "<$cffile") or warn "cannot read $cffile\n";
  while (<IN>) {
    s/#.*$//g; s/^\s+//; s/\s+$//;

    if (/^(header|body|full)\s+(\S+)\s+/) {
      $scores->{$2} ||= 1;
    } elsif (/^score\s+(\S+)\s+(.+)$/) {
      $scores->{$1} = $2;
    }
  }
  close IN;

  $scores;
}

sub found_missed {
  my $score = shift;
  my $id = shift;
  my $tests = shift;

  print "$score $id $tests\n";
}

