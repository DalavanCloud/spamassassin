#!/usr/bin/perl -w

my $threshold = 5;
my $iterlimit = 0;

srand (time ^ $$);
my %is_spam = ();
my %tests_hit = ();

print "Generating baseline results using current scores...\n";
my $total;
readlogs();

my $scores;
readscores();
my $origscores = $scores;

# else use perl loop...

my $results;
counthits();
printhits();
my $origresults = $results;

open (OUT, ">results.baseline");
select OUT;
printhits();
writescores();
close OUT;
exit;

sub counthits {
  $results = { };
  $results->{ny} = $results->{nn} = 0;
  $results->{yy} = $results->{yn} = 0;

  my $file;
  for ($file = 0; $file < $total; $file++) {
    my $hits = 0;

    foreach my $test (@{$tests_hit{$file}}) {
      $hits += $scores->{$test};
    }

    if ($is_spam{$file}) {
      if ($hits > $threshold) {
	$results->{yy}++;
      } else {
	$results->{yn}++;
      }

    } else {
      if ($hits > $threshold) {
	$results->{ny}++;
      } else {
	$results->{nn}++;
      }
    }

    # print "$file: $hits $prevhits{$file}\n";
  }
}

sub printhits {
  $total ||= 1;	# avoid div by 0
  printf "Correctly non-spam: %6d  %3.2f%%\n",
  	$results->{nn}, ($results->{nn} / $total) * 100.0;
  printf "Correctly spam:     %6d  %3.2f%%\n",
  	$results->{yy}, ($results->{yy} / $total) * 100.0;
  printf "False positives:    %6d  %3.2f%%\n",
  	$results->{ny}, ($results->{ny} / $total) * 100.0;
  printf "False negatives:    %6d  %3.2f%%\n",
  	$results->{yn}, ($results->{yn} / $total) * 100.0;
  printf "TOTAL:              %6d  %3.2f%%\n",
  	$total, 100;
}

sub readlogs {
  my $count = 0;
  foreach my $file ("spam.log", "nonspam.log") {
    open (IN, "<$file");

    while (<IN>) {
      /^.\s+(\d+)\s+(\S+)\s*(\S*)/ or next;
      my $hits = $1;
      my @tests = split (/,/, $3);

      # $prevhits{$count} = $hits;
      $tests_hit{$count} = \@tests;

      if ($file eq "spam.log") {
	$is_spam{$count} = 1;
      } else {
	$is_spam{$count} = 0;
      }
      $count++;
    } 
    close IN;
  }
  $total = $count;
}


sub readscores {
  $scores = { };

  open (IN, "<../spamassassin.cf");
  while (<IN>) {
    s/#.*$//g; s/^\s+//; s/\s+$//;

    if (/^(header|body|full)\s+(\S+)\s+/) {
      $scores->{$2} ||= 1;
    } elsif (/^score\s+(\S+)\s+(.+)$/) {
      $scores->{$1} = $2;
    }
  }
  close IN;
}

sub writescores {
  foreach my $name (sort keys %{$scores}) {
    printf "score $name %2.1f\n", $scores->{$name};
  }
}

