#!/usr/bin/perl -w
#
# derived from "re2xs", by Matt Sergeant, at <http://www.sergeant.org/re2xs>;
# see <http://use.perl.org/~Matts/journal/30597> for more details.

use ExtUtils::MakeMaker qw(prompt);
use File::Copy;
use File::Path;
use Getopt::Long;

use constant MAX_RULES => 200;

our $NAME;
our $FORCE;

sub usage {
  print "Usage:
$0 [OPTIONS] file

Options:
  -n, --name N    : Name of the module
  -h, --help      : This page
  -f, --force     : run even if module dir exists
\n";
  exit();
}

GetOptions(
  "name|n=s" => \$NAME,
  "help|h"   => \&usage,
  "force|f"  => \$FORCE,
  );

usage() unless @ARGV;
our $FILE = shift @ARGV;
-e $FILE || die "No such file: $FILE";

open(my $fh, "sort $FILE |") || die "open($FILE): $!";

# read ruleset name from the first line in the file
my $ruleset_name;
$_ = <$fh>;
if (/^name\s+(\S+)/) {
  $ruleset_name = $1;
}

if (!$NAME) {
  $NAME = "Mail::SpamAssassin::CompiledRegexps::$ruleset_name";
}

our $PATH = $NAME;
$PATH =~ s/::/-/g;
our $PMFILE = $NAME;
$PMFILE =~ s/.*:://;
$PMFILE .= ".pm";
our $XSFILE = $PMFILE;
$XSFILE =~ s/\.pm$/.xs/;

$FORCE and rmtree $PATH;
mkdir $PATH or (!$FORCE and die "mkdir($PATH): $!");
chdir $PATH;

my $cprefix = $NAME; $cprefix =~ s/[^A-ZA-z0-9]+/_/gs;

my $numscans = 0;
my (@dot_star, @dot_plus);

my $has_rules = '';

while (!eof($fh)) {
  $numscans++;
  
  open(my $re, ">scanner${numscans}.re") || die "open(>scanner{$numscans}.re): $!";
  
  print $re <<EOT;
#define NULL            ((char*) 0)
#define YYCTYPE         unsigned char
#define YYCURSOR        *p
#define YYLIMIT         *p
#define YYMARKER        q
#define YYFILL(n)
EOT

  print $re <<EOT;
char *${cprefix}_scan${numscans}(unsigned char **p){
unsigned char *q;
/*!re2c
EOT

  my $line = 0;
  while (<$fh>) {
    next if /^#/;

    if (/^orig\s+(\S+)\s+(.*)$/) {
      my $name = $1;
      my $regexp = $2;
      $name =~ s/#/[hash]/gs;
      $regexp =~ s/#/[hash]/gs;
      $has_rules .= "  q#$name# => q#$regexp#,\n";
      next;
    }

    my ($regexp, $reason) = /^r (.*):(.*)$/;
    die "no 'r REGEXP:REASON' in $_" unless defined $regexp;

    if ($regexp =~ /^\.\*/) {
      push @dot_star, "$regexp:$reason";
      next;
    }
    elsif ($regexp =~ /^\.\+/) {
      push @dot_plus, "$regexp:$reason";
      next;
    }
    eval {
      print $re "\t", fixup_re($regexp), "               {return \"$reason\";}\n";
      $line++;
    };
    $@ and handle_fixup_error($@, $regexp, $reason);
    last if $line == MAX_RULES;
  }
  
  print $re <<EOT;
  [\\000-\\377]        { return NULL; }
*/
}
EOT

  #last if $numscans == 2;
}

while (@dot_star) {
  $numscans++;

  open(my $re, ">scanner${numscans}.re") || die "open(>scanner{$numscans}.re): $!";
  
  print $re <<EOT;
#define NULL            ((char*) 0)
#define YYCTYPE         unsigned char
#define YYCURSOR        *p
#define YYLIMIT         *p
#define YYMARKER        q
#define YYFILL(n)
EOT

  print $re <<EOT;
char *${cprefix}_scan${numscans}(unsigned char **p){
unsigned char *q;
start:
/*!re2c
EOT

  my $line = 0;
  while ($_ = shift @dot_star) {
    my ($regexp, $reason) = /^(.*):(.*)$/;
    $regexp =~ s/^\.\*//;
    eval {
      print $re "\t", fixup_re($regexp), "               {return \"$reason\";}\n";
      $line++;
    };
    $@ and handle_fixup_error($@, $regexp, $reason);
    last if $line == MAX_RULES;
  }
  
  print $re <<EOT;
  [\\001-\\377]    { goto start; }
  [\\000]        {return NULL; }
*/
}
EOT
}

while (@dot_plus) {
  $numscans++;

  open(my $re, ">scanner${numscans}.re") || die "open(>scanner{$numscans}.re): $!";
  
  print $re <<EOT;
#define NULL            ((char*) 0)
#define YYCTYPE         unsigned char
#define YYCURSOR        *p
#define YYLIMIT         *p
#define YYMARKER        q
#define YYFILL(n)
EOT

  print $re <<EOT;
char *${cprefix}_scan${numscans}(unsigned char **p){
unsigned char *q;
p++;
start:
/*!re2c
EOT
  
  my $line = 0;
  while ($_ = shift @dot_plus) {
    my ($regexp, $reason) = /^(.*):(.*)$/;
    $regexp =~ s/^\.\+//;

    eval {
      print $re "\t", fixup_re($regexp), "               {return \"$reason\";}\n";
      $line++;
    };
    $@ and handle_fixup_error($@, $regexp, $reason);
    last if $line == MAX_RULES;
  }
  
  print $re <<EOT;
  [\\001-\\377]    { goto start; }
  [\\000]        {return NULL; }
*/

}
EOT
}

print "Running re2c...\n";
for (1..$numscans) {
  print "$_ / $numscans\n";

  my $cmd = "time re2c -i -b -o scanner$_.c scanner$_.re";
  print "$cmd\n";
  system $cmd;

  # this must be fatal; it can result in corrupt output modules missing
  # scannerN() functions
  if ($? >> 8 != 0) {
    my $cwd = `pwd`; chop $cwd;
    die "'$cmd' failed, dying!\n".
        "see $cwd/scanner$_.re\n";
  }
}

open(FILE, ">Makefile.PL") || die "write Makefile.PL: $!";
print FILE <<"EOT";
use ExtUtils::MakeMaker;

WriteMakefile(
    'NAME' => '$NAME',
    'VERSION_FROM' => '$PMFILE',
    'OBJECT' => '\$(O_FILES)',
    'OPTIMIZE' => '-O2',
    'ABSTRACT_FROM' => '$PMFILE',
    'AUTHOR' => 'A. N. Author <author\@example.com>',
);
EOT

open(FILE, ">MANIFEST.SKIP") || die "write MANIFEST.SKIP: $!";
print FILE <<'EOT';
CVS/.*
\.bak$
\.sw[a-z]$
\.tar$
\.tgz$
\.tar\.gz$
\.o$
\.xsi$
\.bs$
^.#
^tmp/
^blib/
^Makefile$
^Makefile\.[a-z]+$
^pm_to_blib$
~$
EOT

open(my $re, ">$XSFILE") || die "write $XSFILE: $!";
print $re <<"EOT";
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

/* split single-space-separated result string */
static void
split_and_add (AV *results, char *match)
{
    char *wordstart, *cp;

    for (cp = wordstart = match; *cp != (unsigned char) 0; cp++) {
      if (*cp == ' ') {
        av_push(results,
            newSVpvn_share(wordstart, cp-wordstart, (U32)0));
        wordstart = cp + 1;
      }
    }
    av_push(results,
            newSVpvn_share(wordstart, cp-wordstart, (U32)0));
}

MODULE = $NAME  PACKAGE = $NAME

PROTOTYPES: DISABLE

SV *
scan(psv)
        SV* psv

  PREINIT:
        int i;
        char *match;
        unsigned char *cursor;
        unsigned char *pstart;
        unsigned char *pend;
        STRLEN plen;
        AV *results;

  CODE:
        pstart = (unsigned char *) SvPVutf8(psv, plen);
        pend = pstart + plen;
        results = (AV *) sv_2mortal((SV *) newAV());
EOT

for (1..$numscans) {
  my $funcname = $cprefix."_scan".$_;

  print $re <<EOT;
        extern char *${funcname} (unsigned char **);

        cursor = pstart;
        while (cursor < pend) {
          while (match = ${funcname} (\&cursor)) {
            split_and_add(results, match);
          }
        }
EOT

}

print $re <<EOT;
        RETVAL = newRV((SV *) results);
    OUTPUT:
        RETVAL

EOT

close($re);

open(FILE, ">$PMFILE") || die "write $PMFILE: $!";
print FILE <<"EOT";

package $NAME;

use strict;
use vars qw(\$VERSION \@ISA \@EXPORT_OK);

use DynaLoader ();

BEGIN {
\$VERSION = '1.0';
\@ISA = qw(DynaLoader);
\@EXPORT_OK = qw();

our \$HAS_RULES = {
  $has_rules
};

bootstrap $NAME \$VERSION;
}

1;
__END__

=head1 NAME

$NAME - Efficient string matching for regexps found in $FILE

=head1 SYNOPSIS

  use $NAME;
  
  ...
  my \$match = ${NAME}::scan(\$string);

=head1 DESCRIPTION

This module is created by re2xs which uses re2c to create an XS library
capable of scanning through a bunch of regular expressions as defined
in F<$FILE>.

That's all for now. Enjoy.

=cut
EOT

sub fixup_re {
  my $re = shift;
  
  # print "FIXUP: $re\n";
  
  my $output = "";
  my $TOK = qr([\{\^\$\"\(\)\[\|\\\.\+\*\?]);
  
  my $STATE;
  while ($re =~ /\G(.*?)($TOK)/gc) {
    my $pre = $1;
    my $tok = $2;

    if (length($pre)) {
      $output .= "\"$pre\"";
    }

    if ($tok eq "(") {
      # Grouping
      my $origpos = pos $re;
      if ($re =~ /\G(.*)\)/gc) {
        # trim that down, if necessary, to just the matching
        # (...) substring.
        my $subre = find_balanced_group($1);
        $output .= "( " . fixup_re($subre) . " )";
        # reset m//g offset to the end of that group, so that
        # the next token is taken from the right place
        pos $re = $origpos + length($subre) + 1;
      }
      else {
        die "re: $re doesn't have group closing bracket";
      }
    }
    elsif ($tok eq "|") {
      $output .= " | ";
    }
    elsif ($tok eq ")") {
      $output .= " ) ";
    }
    elsif ($tok eq "[") {
      # chars
      if ($re =~ /\G(.*?)\]/gc) {
        $output .= "[$1]";
      }
      else {
        die "re: $re doesn't have character class closing bracket";
      }
    }
    elsif ($tok eq '{') {
      if ($re =~ /\G(.*?)\}/gc) {
        $output .= "{$1}";
      }
      else {
        die "re: $re doesn't have quantifier closing bracket";
      }
    }
    elsif ($tok eq '.') {
      $output .= '.';
    }
    elsif ($tok eq '"') {
      $output .= '"\\';     # reversed later to form \"
    }
    elsif ($tok eq '*') {
      # /guaranteed*/ => "guarantee" "d"* , not "guaranteed"*
      $output =~ s/(.)\"\s*$/\" \"$1\"/;
      $output .= '* ';
    }
    elsif ($tok eq '?') {
      # /guaranteed?/ => "guarantee" "d"? , not "guaranteed"?
      $output =~ s/(.)\"\s*$/\" \"$1\"/;
      $output .= '? ';
    }
    elsif ($tok eq '+') {
      # /guaranteed+/ => "guarantee" "d"+ , not "guaranteed"+
      $output =~ s/(.)\"\s*$/\" \"$1\"/;
      $output .= '+ ';
    }
    elsif ($tok eq "^") {
      die "Unsupported anchor: \\$tok";
    }
    elsif ($tok eq "\$") {
      die "Unsupported anchor: \\$tok";
    }
    elsif ($tok eq '\\') {
      $re =~ /\G(.)/gc or die "\\ at end of string!";
      my $esc = $1;
      if ($esc !~ /^
                [\.\@\$\(\)\/\-\+\*\^\?\!_]
                $/x)
      {
        die "Unsupported escape: \\$esc";
      }
      $output .= "\"$esc\"";
    }
    else {
      print "PRE: $pre\nTOK: $tok\n";
    }
  }
  
  if (!defined(pos($re))) {
    # no matches
    $output .= "\"$re\"";
  }
  elsif (pos($re) <= length($re)) {
    $output .= fixup_re(substr($re, pos($re)));
  }
  
  $output =~ s/""//g; # strip empty strings, or turn "abc""def" -> "abcdef"
  # print "OUTPUT: $output\n";
  return $output;
}

sub handle_fixup_error {
  my ($strat, $regexp, $reason) = @_;
  if ($strat) {
    warn "skipped: $regexp: $strat";
  }
}

sub find_balanced_group {
  my ($re) = @_;

  # $re could be:
  #
  #   foo
  #   foo|bar|baz
  #   foo(aa|bb|cc)|bar|baz
  #   foo(aa|(bb|cc|ddd))|bar(e|f)
  #
  # or, due to inefficient regexp parsing above:
  #
  #   foo) totally_unrelated_text (next_grouping => "foo"
  #
  # all we have to do here is ensure that we correctly pick out
  # the balanced group.

  my $output = "";
  my $TOK = qr([\(\\\)]);
  my $level = 0;
  
  my $STATE;
  while ($re =~ /\G(.*?)($TOK)/gc) {
    my $pre = $1;
    my $tok = $2;

    if (length($pre)) {
      $output .= $pre;
    }

    if ($tok eq "(") {
      $output .= $tok;
      $level++;
    }
    elsif ($tok eq ")") {
      $level--;
      if ($level < 0) {
        # we found the matching close-bracket; stop searching here
        # warn "JMD partial $re => $output";
        return $output;
      }
      $output .= $tok;
    }
    elsif ($tok eq '\\') {
      $re =~ /\G(.)/gc or die "\\ at end of string!";
      my $esc = $1;
      $output .= $tok.$esc;
    }
    else {
      $output .= $tok;
    }
  }

  if (!defined(pos($re))) {
    $output .= $re;
  }
  elsif (pos($re) <= length($re)) {
    $output .= substr($re, pos($re));
  }

  # we hit end-of-string; in other words, it was a balanced re anyway
  # warn "JMD fully balanced $re";
  return $re;
}

