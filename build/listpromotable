#!/usr/bin/perl

use strict;
use warnings;

use File::Temp ();
use LWP::Simple;
use URI::Escape;
use Data::Dumper;

my $FROM_CACHE = 1;
my $MAKE_CACHE = 1;

###########################################################################

my $cgi_url = "http://buildbot.spamassassin.org/";
my $doc;

if ($FROM_CACHE == 0) {
  my $url = $cgi_url."ruleqa?daterev=last-night";
  $doc = get ($url);
  if (!$doc) {
    die "HTTP get failed: $doc\n";
  }

  if ($MAKE_CACHE) {
    open(O, ">ruleqa.cache"); print O $doc; close O;
  }
}
else {
  open(I, "<ruleqa.cache") or die; $doc = join('',<I>); close I;
}

###########################################################################

# <rule><test>__HIGHBITS</test><promo>0</promo>
# <spc>8.7654</spc><hpc>0.2056</hpc><so>0.977</so>
# <detailhref>ruleqa%3Fdaterev%3Dlast-night%26rule%3D__HIGHBITS%26s_detail%3D1</detailhref></rule>

my $plist = { };
while ($doc =~ m!<rule>(.*?)</rule>!xg) {
  my $xml = $1;
  my $obj = { };

  while ($xml =~ s!<([A-Za-z0-9_]+)>(.*?)</\1>!!) {
    $obj->{$1} = $2;
  }
  while ($xml =~ s!<([A-Za-z0-9_]+)\s+esc=["']1["']>(.*?)</\1>!!) {
    $obj->{$1} = uri_unescape($2);
  }

  my $name = $obj->{test};
  $obj->{detailhref} = $cgi_url.$obj->{detailhref};

  $plist->{$name} = $obj;
}

if (!scalar keys %$plist) {
  die "no rules found?\n$doc\n";
}

###########################################################################

## my $dump = Data::Dumper->Dump([$plist], ['promolist']); print $dump;

# use SpamAssassin classes directly, so we can lint rules
# as we go
use lib 'lib';
use Mail::SpamAssassin;

my $mailsa = Mail::SpamAssassin->new({
    rules_filename => "rules",
    site_rules_filename => join("\000", qw( rulesrc/core rulesrc/sandbox )),
    local_tests_only => 1,
    dont_copy_prefs => 1,
    config_tree_recurse => 1,
    # debug => 1,
});

# hack hack hack!!  we don't want to load plugin files twice,
# and since the mkrules compiler copies from rulesrc/sandbox/*/*.pm
# to rules/*.pm, they would otherwise appear twice.
foreach my $fname (<rules/*.pm>) {
  my $path = File::Spec->rel2abs($fname);
  $INC{$path} = 1;
  # warn "JMD $path";
}

my %rules_with_errors = ();

$mailsa->{lint_callback} = sub {
  my %opts = @_;

  return if ($opts{msg} =~ /
        (?:score\sset\sfor\snon-existent|description\sexists)
    /x);

  warn "demoting $opts{rule}: $opts{msg}";
  if ($opts{iserror}) {
    $rules_with_errors{$opts{rule}}++;
  }
};

$mailsa->lint_rules();

my $date = scalar localtime time;
print "# active ruleset list generated on $date\n";
foreach my $name (sort keys %$plist) {
  my $obj = $plist->{$name};
  my $notes = '';

  next unless ($mailsa->{conf}->{descriptions}->{$name}
        || $mailsa->{conf}->{scores}->{$name});

  # "nopublish" tflags
  my $tfs = $mailsa->{conf}->{tflags}->{$name};
  if ($tfs) {
    next if ($tfs =~ /\bnopublish\b/);

    # all of these tflags force publication
    if ($tfs =~ /\b(publish|userconf|learn)\b/) {
      $notes = "tflags ".$1;
      goto publish;
    }
  }

  # ignore rules that are not marked as promotable
  next unless ($obj->{promo});

  # only rules from "rulesrc" dirs
  my $src = $mailsa->{conf}->{source_file}->{$name};
  next if (!$src || $src !~ /rulesrc/);

  # rules that fail lint
  next if $rules_with_errors{$name};

  $notes = "spam=$obj->{spc} ham=$obj->{hpc} so=$obj->{so}";

publish:

  print "\n# $notes\n$name\n";
}


## # now write that to a tmp file so 'mkrules' can use it
## my $tmp = new File::Temp( UNLINK => 1, SUFFIX => '.pl' );
## print $tmp $dump;
## 
## my $perl = $^X;
## if (!$perl) {
## die "no perl path found in ARGV!";
## }
## 
## # and exec that script
## exec $perl, "build/mkrules", "--listpromotable=$tmp";
## die "exec failed";

