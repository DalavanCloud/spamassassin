#!/usr/bin/perl

use strict;
use warnings;

use Getopt::Long;
use IPC::DirQueue;

use vars qw(
    $pidfile
    $opt_enq
);
GetOptions(
    "pidfile=s" => \$pidfile,
    "enq=s" => \$opt_enq,
);

my $dq_fast = IPC::DirQueue->new({ dir => "/home/automc/freqsd/dq_fast" });
my $dq_slow = IPC::DirQueue->new({ dir => "/home/automc/freqsd/dq_slow" });
$pidfile ||= "/home/automc/freqsd/pid";

$ENV{HOME} = '/home/bbmass';
umask(022);

# ---------------------------------------------------------------------------

# by separating this into two processes, we can get the parent reports issued
# immediately, and the slow reports can gronk away in the background.
# by using IPC::DirQueue,

# the parent process continually generates the faster reports
my $parent_reports = "LOGS.all DETAILS.new DETAILS.all DETAILS.age ".
  "HTML.new HTML.all HTML.age NET.new NET.all NET.age SCOREMAP.new";

# the child process generates the slow reports
my $child_reports = "OVERLAP.new";

# seconds between build-polls
my $idle_sleep = 30;

# ---------------------------------------------------------------------------

if ($opt_enq) {
  $dq_fast->enqueue_string("", { dir => $opt_enq });
  $dq_slow->enqueue_string("", { dir => $opt_enq });
  exit;
}

# ---------------------------------------------------------------------------

sub run;
my $am_parent;
my $child_pid = fork();
if ($child_pid < 0) {
  die "fork failed";
}
elsif ($child_pid != 0) {
  $am_parent = 0;
}
else {
  $am_parent = 1;
}

$SIG{INT} = \&sigterm_handler;
$SIG{TERM} = \&sigterm_handler;

if ($pidfile) {
  open(OUT, ">$pidfile") or die "cannot write to $pidfile";
  print OUT $$;
  close OUT or die "cannot save $pidfile";
}

if ($am_parent) {
  while (1) {
    parent_loop();
  }
}
else {
  while (1) {
    child_loop();
  }
}

# ---------------------------------------------------------------------------

sub parent_loop {
  my $job = $dq_fast->wait_for_queued_job($idle_sleep);

  print "starting faster reports ($$) at ".(scalar localtime time)."\n";

  # add optional --dir switch
  my $logdir = '';
  if ($job->{metadata}->{dir}) {
    $logdir = "--dir ".$job->{metadata}->{dir};
  }

  run ("cd masses/rule-qa ; ./corpus-hourly ".
        "--override='output_classes=$parent_reports' ".
        "$logdir");

  run ("cd masses ; ./rule-qa/automc/gen_info_xml");

  print "completed faster reports ($$) at ".(scalar localtime time)."\n";

  if ($job) {
    $job->finish();
  }
}

# ---------------------------------------------------------------------------

sub child_loop {
  my $job = $dq_fast->wait_for_queued_job($idle_sleep);

  print "starting slow reports ($$) at ".(scalar localtime time)."\n";

  # add optional --dir switch
  my $logdir = '';
  if ($job->{metadata}->{dir}) {
    $logdir = "--dir ".$job->{metadata}->{dir};
  }

  run ("cd masses/rule-qa; ./corpus-hourly ".
        "--override='output_classes=$child_reports' ".
        "$logdir");

  print "completed slow reports ($$) at ".(scalar localtime time)."\n";

  sleep $idle_sleep;        # sleep until timeout, or we get SIGHUPped
}

# ---------------------------------------------------------------------------

sub sigterm_handler {
  warn "received SIGTERM at ".(scalar localtime time)."\n";
  kill(15, $child_pid);
  if ($pidfile) { unlink($pidfile); }
  die "terminated";
}

# ---------------------------------------------------------------------------

sub run {
  my ($cmd, $ignoreexit) = @_;

  print "[$cmd]\n";
  system ($cmd);

  if (!$ignoreexit) {
    die "command '$cmd' failed with status $?" if (($? >> 8) != 0);
  }
}

