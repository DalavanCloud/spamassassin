#!/local/perl586/bin/perl

use strict;
use warnings;

use Getopt::Long;
use IPC::DirQueue;

use vars qw(
    $pidfile
    $opt_enq
    $opt_kill
);
GetOptions(
    "pidfile=s" => \$pidfile,
    "enq=s" => \$opt_enq,
    "kill" => \$opt_kill,
);

my $dq_fast = IPC::DirQueue->new({ dir => "/home/automc/freqsd/dq_fast" });
my $dq_slow = IPC::DirQueue->new({ dir => "/home/automc/freqsd/dq_slow" });
$pidfile ||= "/home/automc/freqsd/pid";

# $ENV{HOME} = '/home/bbmass';
umask(002);

# ---------------------------------------------------------------------------

# by separating this into two processes, we can get the parent reports issued
# immediately, and the slow reports can gronk away in the background.
# by using IPC::DirQueue,

# the parent process continually generates the faster reports
my $parent_reports = "LOGS.all DETAILS.new DETAILS.all DETAILS.age ".
  "HTML.new HTML.all HTML.age NET.new NET.all NET.age SCOREMAP.new";

# the child process generates the slow reports
my $child_reports = "OVERLAP.new";

# seconds between build-polls
my $idle_sleep = 600;

# ---------------------------------------------------------------------------

if ($opt_enq) {
  $dq_fast->enqueue_string("", { dir => $opt_enq });
  $dq_slow->enqueue_string("", { dir => $opt_enq });
  exit;
}

if ($opt_kill) {
  die "no -pidfile" unless $pidfile;
  open (IN, "<$pidfile") or die "cannot read $pidfile";
  my $pid = <IN> + 0;
  close IN;
  if ($pid < 2) {
    die "invalid pid: '$pid'";
  }
  kill (15, $pid) or die "kill $pid failed: $!";
  exit;
}

# ---------------------------------------------------------------------------

sub run;
my $am_parent;
my $child_pid = fork();
if ($child_pid < 0) {
  die "fork failed";
}
elsif ($child_pid != 0) {
  $am_parent = 0;
}
else {
  $am_parent = 1;
  $SIG{INT} = \&sigterm_handler;
  $SIG{TERM} = \&sigterm_handler;
}

if ($pidfile) {
  open(OUT, ">$pidfile") or die "cannot write to $pidfile";
  print OUT $$;
  close OUT or die "cannot save $pidfile";
}

$| = 1;
print "freqsd starting: process $$\n";

if ($am_parent) {
  while (1) {
    parent_loop();
  }
}
else {
  while (1) {
    child_loop();
  }
}

# ---------------------------------------------------------------------------

sub logit {
  print "LOG: ".join('', @_)." ($$) at ".(scalar localtime time)."\n";
}

sub parent_loop {
  my $job = $dq_fast->wait_for_queued_job($idle_sleep);

  # add switches
  my $opts = '';
  if ($job && $job->{metadata}->{dir}) {
    logit "starting requested faster reports";
    # if a dir was specified, it's always a "b" (buildbot) mass-check;
    # that's the assumption here at least
    $opts = "--tag=b --dir ".$job->{metadata}->{dir};
  }
  else {
    logit "starting idle-time faster reports";
    $opts = "--tag=n";      # nightly
    # may also be weekly.  no way to differentiate currently until
    # AFTER corpus.hourly is run!  TODO?
  }

  run ("cd masses/rule-qa ; ./corpus-hourly ".
        "--override='output_classes=$parent_reports' ".
        "$opts");

  run ("cd masses ; ./rule-qa/automc/gen_info_xml");

  if ($job) {
    $job->finish();
  }

  logit "completed faster reports";
}

# ---------------------------------------------------------------------------

sub child_loop {
  my $job = $dq_fast->wait_for_queued_job($idle_sleep);

  # add switches
  my $opts = '';
  if ($job && $job->{metadata}->{dir}) {
    logit "starting requested slow reports";
    $opts = "--tag=b --dir ".$job->{metadata}->{dir};
  }
  else {
    logit "starting idle-time slow reports";
    $opts = "--tag=n";      # nightly
  }

  # create slow reports
  run ("cd masses/rule-qa; ./corpus-hourly ".
        "--override='output_classes=$child_reports' ".
        $opts);

  logit "running 'freqsd-infrequent' tasks";

  # recreate the corpus link-farm
  run ("build/automc/freqsd-infrequent");

  if ($job) {
    $job->finish();
  }

  logit "completed slow reports";
}

# ---------------------------------------------------------------------------

sub sigterm_handler {
  warn "received SIGTERM at ".(scalar localtime time)."\n";
  kill(15, $child_pid);
  if ($pidfile) { unlink($pidfile); }
  die "terminated";
}

# ---------------------------------------------------------------------------

sub run {
  my ($cmd, $ignoreexit) = @_;

  print "[$cmd]\n";
  system ($cmd);

  if (!$ignoreexit) {
    die "command '$cmd' failed with status $?" if (($? >> 8) != 0);
  }
}

