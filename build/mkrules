#!/usr/bin/perl -w
# 
# build/mkrules -- compile the SpamAssassin rules into installable form
#
# <@LICENSE>
# Copyright 2004 Apache Software Foundation
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# </@LICENSE>

# This is an implementation of
# http://wiki.apache.org/spamassassin/RulesProjPromotion 

sub usage {
  die "mkrules/run [--src srcdir] [--out outputdir]\n";
}

use strict;
use File::Find;
use File::Copy;
use Getopt::Long;

# use SpamAssassin classes directly, so we can lint rules
# as we go
use lib 'lib';
use Mail::SpamAssassin;

use vars qw(
    @opt_srcs $opt_out $opt_sandboxout $opt_manifest
    $opt_manifestskip $opt_listpromotable $opt_active
    $opt_activeout
);
GetOptions("src=s" => \@opt_srcs,
    "out=s",
    "sandboxout=s",
    "activeout=s",
    "active=s",
    "manifest=s",
    "manifestskip=s",
  );

if (!@opt_srcs) {
  foreach ( 'rulescode', 'rulesrc' ) {
    if (-d $_) {
      # print "using default src $_\n";
      push(@opt_srcs, $_);
    }
  }
}

if (!$opt_manifest && -f "MANIFEST") {
  $opt_manifest = "MANIFEST";
}

if (!$opt_manifestskip && -f "MANIFEST.SKIP") {
  $opt_manifestskip = "MANIFEST.SKIP";
}

if (!$opt_active && -f "rules/active.list") {
  $opt_active = "rules/active.list";
}

die "no src" unless (@opt_srcs >= 1);

my $promolist;

  die "no out" unless ($opt_out);
  die "unreadable out" unless (-d $opt_out);
  die "unreadable active" unless (-f $opt_active);

$opt_sandboxout ||= "70_sandbox.cf";
$opt_activeout  ||= "72_active.cf";

# source files that need compilation, and their targets
my $needs_compile = { };
my $current_src;


foreach my $src (@opt_srcs) {
  if (!-d $src) {
    warn "WARNING: unreadable src '$src'\n";
    next;
  }
  $current_src = $src;
  File::Find::find ({
          wanted => \&wanted,
          no_chdir => 1
        }, $src);
}

my $rules = { };

my $file_manifest = { };
my $file_manifest_skip = [ ];
if ($opt_manifest) {
  read_manifest($opt_manifest);
}
if ($opt_manifestskip) {
  read_manifest_skip($opt_manifestskip);
}

my $active_rules = { };
read_active($opt_active);

# context for the rules compiler
my $seen_rules = { };
my $renamed_rules = { };
my $output_files = { };
my $output_file_text = { };
my $files_to_lint = { };

# $COMMENTS is a "catch-all" "name", for lines that appear after the last line
# that refers to a rule by name.  Those lines are not published by themselves;
# they'll be published to all pubfiles found in the file.
#
# It's assumed they are comments, because they generally are, but could be all
# sorts of unparseable lines.
my $COMMENTS = '!comments!';

# another "fake name" for lines that should always be published.  They'll
# be published to all files, in duplicate.  This should probably be improved
# somehow, TODO.
my $ALWAYS_PUBLISH = '!always_publish!';

read_all_rules($needs_compile);
compile_output_files();
lint_output_files();
write_output_files();

exit;

# ---------------------------------------------------------------------------

sub lint_output_files {
  foreach my $file (keys %{$files_to_lint}) {
    my $text = join("\n", "file start $file", $output_file_text->{$file}, "file end $file");
    if (lint_rule_text($text) != 0) {
      warn "\nERROR: LINT FAILED, suppressing output: $file\n\n";
      delete $output_file_text->{$file};
    }
  }
}

sub lint_rule_text {
  my ($text) = @_;
  my $mailsa = Mail::SpamAssassin->new({
      rules_filename => "./rules",
      # debug => 1,
      local_tests_only => 1,
      dont_copy_prefs => 1,
      config_text => $text
  });

  my $errors = 0;
  $mailsa->{lint_callback} = sub {
    my %opts = @_;

    return if ($opts{msg} =~ /
          (?:score\sset\sfor\snon-existent|description\sexists)
      /x);

    warn "lint: $opts{msg}";
    if ($opts{iserror}) {
      $errors++;
    }
  };

  return $errors;       # 0 means good
}

sub wanted {
  my $path = $File::Find::name;
  # only files
  return if (!-f $path);
  
  # limit what will be copied from sandboxes
  return if ($path =~ /sandbox/ && !/(?:\d.*\.cf|\.pm)$/i);

  # a bit of sanity please - no svn metadata ;)
  return if ($path =~ /\.svn/);

  my $dir = $path;
  $dir =~ s/^${current_src}[\/\\\:]//s;
  $dir =~ s/([^\/\\\:]+)$//;
  my $filename = $1;


  my $f = "$current_src/$dir$filename";
  my $t;
  $t = "$opt_out/$filename";

  $needs_compile->{$f} = {
          f => $f,
          t => $t,
          dir => $dir,
          filename => $filename
        };
}

# compile all the source files found by the wanted() sub, in sorted
# order so that the order of precedence makes sense.
sub read_all_rules {
  my ($sources) = @_;

  # deal with the perl modules first, so that later linting w/ loadplugin will
  # work appropriately.
  foreach my $f (sort {
    my ($ae) = $a =~ /\.(cf|pm)$/;
    my ($be) = $b =~ /\.(cf|pm)$/;
    return $be cmp $ae || $a cmp $b;
    } keys %$sources) {

    my $entry = $needs_compile->{$f};
    my $t = $entry->{t};

    # TODO: dependency checking optimization?
    ## my $needs_rebuild = 0;
    ## if (!-f $t || -M $t > -M $f) {
    ## # the source file is newer, or dest is not there
    ## $needs_rebuild = 1;     
    ## }

    my $needs_rebuild = 1;

    if ($entry->{filename} =~ /\.pm$/) {
      plugin_file_compile($entry);
    }
    elsif ($entry->{dir} =~ /sandbox/) {
      rule_file_compile($f, $t, $entry->{filename}, 1);
    }
    elsif ($entry->{dir} =~ /extra/) {
      # 'extra' rulesets; not built by default (TODO)
      next;
    }
    else {
      # rules in "core" and "lang" are always copied
      if ($needs_rebuild) {
        rule_file_compile($f, $t, $entry->{filename}, 0);
      }
    }
  }
}

###########################################################################

# Rules are compiled from source dir to output dir.
# 
# Rules in "rules/active.list" are promoted to "72_active.cf"; rules not
# listed there are relegated to "70_sandbox.cf".  There is code to allow
# other filenames to be selected from the rulesrc .cf file, but I'm not
# sure if it works anymore ;)
# 
# Rules will be autorenamed, if there's a collision between a new rule name and
# one that's already been output by the compiler in another source file. The
# autorenaming is very simple -- portions of the current source path are
# appended to the rule name, sanitised.

sub rule_file_compile {
  my ($f, $t, $filename, $issandbox) = @_;

  open (IN, "<$f") or die "cannot read $f";

  # a fast parser for the config file format; don't need the
  # full deal here, and it must be fast, since it's run on every
  # "make" invocation

  my $rule_order = [ ];

  my $lastrule = $COMMENTS;

  if (!defined $rules->{$ALWAYS_PUBLISH}) {
    $rules->{$ALWAYS_PUBLISH} = rule_entry_create();
  }

  my $ALWAYS = { $ALWAYS_PUBLISH => 1 };

  # an "ifplugin" or "if" scope
  my $current_conditional;
  my $current_comments = '';

  while (<IN>) {
    my $orig = $_;

    s/^#reuse/reuse/;   # TODO - dirty hack.  we need to fix this to just be
    # a keyword which the engine ignores, this is absurd! 

    s/#.*$//g; s/^\s+//; s/\s+$//;

    # send comments/blank lines to the holding area for next rule
    if (/^$/) {
      $current_comments .= $orig;
      next;
    }

    # save "lang" declarations
    my $lang = '';
    if (s/^lang\s+(\S+)\s+//) {
      $lang = $1;
    }

    if (/^
        (header|rawbody|body|full|uri|meta|mimeheader|describe|
        tflags|reuse|score)
        \s+(\S+)\s+(.*)$
      /x)
    {
      # rule definitions
      my $type = $1;
      my $name = $2;
      my $val = $3;

      my $origname = $name;
      if ($issandbox) {
        $name = sandbox_rule_name_avoid_collisions($name, $f);
      }
      # non-sandbox rules always use the same name

      if (!$rules->{$name}) { $rules->{$name} = rule_entry_create(); }
      $rules->{$name}->{origname} = $origname;
      $rules->{$name}->{cond} = $current_conditional;
      $rules->{$name}->{text} .= $current_comments . $orig;
      $rules->{$name}->{srcfile} = $f;

      $current_comments = '';

      $lastrule = $name;
      push (@$rule_order, $name);
    }
    elsif (/^
        (pubfile|publish)
        \s+(\S+)\s*(.*?)$
      /x)
    {
      # preprocessor directives
      my $command = $1;
      my $name = $2;
      my $val = $3;

      my $origname = $name;
      if ($issandbox) {
        $name = sandbox_rule_name_avoid_collisions($name, $f);
      }

      if (!$rules->{$name}) { $rules->{$name} = rule_entry_create(); }
      $rules->{$name}->{origname} = $origname;

      if ($command eq 'publish') {
        # the 'publish' command defaults to "1", unless it explicitly
        # is set to "0".  iow: publish RULE_NAME [(0 | 1)]  [default: 1]
        if (!defined $val) { $val = '1'; }
      }
      elsif ($command eq 'pubfile') {
        if (!filename_in_manifest($opt_out.'/'.$val)) {
          warn "$val: WARNING: not listed in manifest file, using default\n";
          next;     # don't set 'pubfile' below
        }
      }

      $rules->{$name}->{$command} = $val;
    }
    elsif (/^
        (if|ifplugin)
        \s+(.*?)$
      /x)
    {
      $current_conditional = $orig;
    }
    elsif (/^endif\b/x)
    {
      undef $current_conditional;
    }
    elsif (/^loadplugin\s*(\S+)\b/) {
      my $name = 'loadplugin';
      if (!$rules->{$name}) { $rules->{$name} = rule_entry_create(); }
      $rules->{$name}->{text} .= $orig;
      unshift (@$rule_order, $name);
    }
    else {
      my $NAME = $ALWAYS_PUBLISH;
      if ($current_conditional) {

        $NAME .= $current_conditional . '!';
        $NAME =~ s/\n//gs;

        unless ($rules->{$NAME}) {
	  $rules->{$NAME} = rule_entry_create();
	  $ALWAYS->{$NAME} = 1;
	}
	$rules->{$NAME}->{cond} = $current_conditional;
      }

      # warn "unknown line in rules file '$f', saving to default: $orig";
      $rules->{$NAME}->{text} .= $orig;
    }
  }
  close IN;

  if ($current_comments) {
    $rules->{$COMMENTS}->{text} .= $current_comments;
  }

  # now append all the found text to the output file buffers
  copy_to_output_buffers($rule_order, $issandbox, $ALWAYS, $f, $filename);

  # ok; file complete.  now mark all those rules as "seen"; future
  # refs to those rule names will trigger an autorename.
  foreach my $name (@$rule_order) {
    $seen_rules->{$name} = 1;
  }
}

sub copy_to_output_buffers {
  my ($rule_order, $issandbox, $ALWAYS, $f, $filename) = @_;

  my %already_done = ();
  my $copied = 0;
  foreach my $name (@$rule_order, keys(%$ALWAYS))
  {
    # only do each rule once, please ;)
    next if exists $already_done{$name};
    $already_done{$name} = undef;

    my $text = $rules->{$name}->{text};
    if (!$text) {
      next;     # nothing to write!
    }

    my $srcfile = $rules->{$name}->{srcfile};
    my $pubfile = pubfile_for_rule($rules, $name);

    $output_files->{$pubfile} = {
      header => "",
      # header => "# [compiled from '$srcfile']\n",
      # don't use that header; we now have multiple srcfiles in each
      # output file!
    };

    # fix up any rule renamings we were supposed to do
    sed_renamed_rule_names(\$text);

    my $cond = $rules->{$name}->{cond};
    if ($cond) {
      $rules->{$name}->{output_text} = "\n".$cond.$text."endif\n";
    } else {
      $rules->{$name}->{output_text} = $text;
    }
    $rules->{$name}->{output_file} = $pubfile;

    $copied++;
  }

  print "$f: $copied ".
    ($issandbox ? "sandbox" : "core")." rules copied\n";
}

sub pubfile_for_rule {
  my ($rules, $name) = @_;

  my $pubfile;
  if ($rules->{$name}->{publish}) {
    $pubfile = $rules->{$name}->{pubfile};
    if ($pubfile) {
      $pubfile = $opt_out.'/'.$pubfile;
    }
  }

  # default: "70_sandbox.cf" or "72_active.cf"
  if (!$pubfile) {
    if ($active_rules->{$name}) {
      $pubfile = $opt_out.'/'.$opt_activeout;
    } else {
      $pubfile = $opt_out.'/'.$opt_sandboxout;
    }
  }
  return $pubfile;
}

sub plugin_file_compile {
  my ($entry) = @_;

  return if $opt_listpromotable;
  # just copy the raw perl module over to the new area
  # we can't really rename to avoid conflicts since the loadplugin lines
  # are going to be all screwed up in that case.
  # jm: we always want to update the output file in case the input
  # has been changed!
  if (0 && -e $entry->{t}) {
    warn "The perl module ".$entry->{t}." already exists, can't copy from ".$entry->{f}."\n";
  }
  else {
    copy($entry->{f}, $entry->{t}) || warn "Couldn't copy ".$entry->{f}.": $!";
  }
}

###########################################################################

sub compile_output_files {
  # create all known output files
  foreach my $file (keys %$output_files) {
    my $always_publish_text = $rules->{$ALWAYS_PUBLISH}->{output_text};

    $output_file_text->{$file} = $output_files->{$file}->{header}.
        $always_publish_text;
  }

  my @rulenames = sort keys %$rules;
  my %seen = ();

  # go through the rules looking for meta subrules we
  # may have forgotten; this happens if a non-subrule is
  # listed in active.list, the subrules will not be!  fix them
  # to appear in the same output file as the master rule.
  foreach my $rule (@rulenames) {
    fix_up_rule_dependencies($rule);
  }

  # now repeat, just for rules in the active set; their dependencies should
  # always be likewise promoted into the active set, overriding the prev step.
  foreach my $rule (@rulenames) {
    my $pubfile = $rules->{$rule}->{output_file};
    next unless ($pubfile && $pubfile =~ /\Q$opt_activeout\E/);
    fix_up_rule_dependencies($rule);
  }

  # output the known rules that are not meta subrules.
  foreach my $rule (@rulenames) {
    next if ($rule =~ /^__/);
    my $pubfile = $rules->{$rule}->{output_file};
    my $text    = $rules->{$rule}->{output_text};
    next unless defined ($text);
    $output_file_text->{$pubfile} .= "## ".$rule."\n".$text."\n";
  }

  # now output all subrules (in a slightly more compact form)
  foreach my $rule (@rulenames) {
    next unless ($rule =~ /^__/);
    my $pubfile = $rules->{$rule}->{output_file};
    my $text    = $rules->{$rule}->{output_text};
    next unless defined ($text);
    $output_file_text->{$pubfile} .= $text;
  }

  # finally, finish off all output files
  foreach my $file (keys %$output_files) {
    # do we have any end-of-file comments?  if so, add it
    # off: results in comments being duplicated many times
    # my $cmts = $rules->{$COMMENTS}->{text};
    # if ($cmts) {
      # $output_file_text->{$pubfile} .= $cmts;
    # }

    # and get them lint-checked!
    $files_to_lint->{$file} = 1;
  }
}

sub fix_up_rule_dependencies {
  my $rule = shift;

  # next if ($rule =~ /^__/);
  my $pubfile = $rules->{$rule}->{output_file};
  my $text    = $rules->{$rule}->{output_text};
  return unless $text;
  
  while ($text =~ /^\s*meta\s+(.*)$/mg) {
    my $line = $1;
    while ($line =~ /\b([_A-Za-z0-9]+)\b/g) {
      # force that subrule (if it exists) to output in the
      # same pubfile
      my $rule2 = $1;
      next unless ($rules->{$rule2} && $rules->{$rule2}->{output_text});
      $rules->{$rule2}->{output_file} = $pubfile;
    }
  }
}

sub write_output_files {
  foreach my $pubfile (sort keys %$output_files) {
    if (-f $pubfile) {
      unlink $pubfile or die "cannot remove output file '$pubfile'";
    }

    if (!filename_in_manifest($pubfile)) {
      # if (!filename_in_manifest($opt_out.'/'.$val)) {
      warn "$pubfile: WARNING: not listed in manifest file\n";
    }

    if ($output_file_text->{$pubfile}) {
      open (OUT, ">".$pubfile) or die "cannot write to output file '$pubfile'";
      print OUT $output_file_text->{$pubfile};
      close OUT or die "cannot close output file '$pubfile'";
      # print "$pubfile: written\n";        # too noisy
    }
    else {
      print "$pubfile: no rules promoted\n";
    }
  }
}

###########################################################################

sub rule_entry_create {
  return {
    text => '',
    publish => 0
  };
}

###########################################################################

sub sandbox_rule_name_avoid_collisions {
  my ($rule, $path) = @_;
  my $new;
  my $newreason;

  return $rule if $opt_listpromotable;

  if ($rule !~ /^(?:T_|__)/) {
    $new = "T_".$rule;
    $newreason = "missing T_ prefix";
  }
  elsif (!exists $seen_rules->{$rule}) {
    return $rule;
  }
  else {
    $new = $path;
    $new =~ s/[^A-Za-z0-9]+/_/gs;
    $new =~ s/_+/_/gs;
    $new =~ s/^_//;
    $new =~ s/_$//;
    $new = $rule.'_'.$new;
    $newreason = "collision with existing rule";
  }

  if (!$renamed_rules->{$new}) {
    $renamed_rules->{$new} = $rule;
    warn "WARNING: $rule: renamed as $new due to $newreason\n";
  }

  return $new;
}

sub sed_renamed_rule_names {
  my ($textref) = @_;
  foreach my $new (keys %{$renamed_rules}) {
    my $rule = $renamed_rules->{$new};
    $$textref =~ s/\b${rule}\b/${new}/gs;
  }
}

###########################################################################

sub read_manifest {
  my ($mfest) = @_;
  open (IN, "<$mfest") or warn "cannot read $mfest";
  while (<IN>) {
    next if /^#/;
    /^\s*(.*?)\s*$/ and $file_manifest->{$1} = 1;
  }
  close IN;
}

sub read_manifest_skip {
  my ($mfest) = @_;
  open (IN, "<$mfest") or warn "cannot read $mfest";
  while (<IN>) {
    next if /^#/;
    /^\s*(.*?)\s*$/ and push (@{$file_manifest_skip}, qr/$1/);
  }
  close IN;
}

sub read_active {
  my ($fname) = @_;
  open (IN, "<$fname") or die "cannot read $fname";
  while (<IN>) {
    s/#.*$//; next if /^\s*$/;
    /^(\S+)/ and $active_rules->{$1} = 1;
  }
  close IN;
}

sub filename_in_manifest {
  my ($fname) = @_;
  return 1 if ($file_manifest->{$fname});
  foreach my $skipre (@{$file_manifest_skip}) {
    # warn "JMD $skipre $fname";
    return 1 if ($fname =~ $skipre);
  }
  return 0;
}


__DATA__

TODO list for this script:

- license blocks at the top of each rulesrc/*/*.cf file need to be
  ignored when compiling, instead of being duplicated into the
  compiled output files.

