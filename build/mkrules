#!/usr/bin/perl -w
# 
# build/mkrules -- compile the SpamAssassin rules into installable form
#
# <@LICENSE>
# Copyright 2004 Apache Software Foundation
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# </@LICENSE>

# This is an implementation of
# http://wiki.apache.org/spamassassin/RulesProjPromotion 

sub usage {
  die "mkrules/run [--src srcdir] [--out outputdir]\n";
}

use strict;
use File::Find;
use File::Copy;

use Getopt::Long;
use vars qw(@opt_srcs $opt_out $opt_sandboxout);
GetOptions("src=s" => \@opt_srcs, "out=s", "sandboxout=s");

if (!@opt_srcs) {
  foreach ( 'rulescode', 'rulesrc' ) {
    if (-d $_) {
      print "using default src $_\n";
      push(@opt_srcs, $_);
    }
  }
}

die "no src" unless (@opt_srcs >= 1);
die "no out" unless ($opt_out);
die "unreadable out" unless (-d $opt_out);

$opt_sandboxout ||= "$opt_out/70_sandbox.cf";

# source files that need compilation, and their targets
my $needs_compile = { };
my $current_src;

foreach my $src (@opt_srcs) {
  die "unreadable src" unless (-d $src);
  $current_src = $src;
  File::Find::find ({
          wanted => \&wanted,
          no_chdir => 1
        }, $src);
}

# context for the rules compiler
my $seen_rules = { };
my $said_renamed_warning = { };
my $output_files = { };
my $output_file_text = { };

compile_sorted($needs_compile);
write_output_files();

exit;

sub wanted {
  my $path = $File::Find::name;
  # only files
  return if (!-f $path);
  
  # limit what will be copied from sandboxes
  return if ($path =~ /sandbox/ && !/\d.*\.(?:cf|pm)$/i);

  # a bit of sanity please - no svn metadata ;)
  return if ($path =~ /\.svn/);

  my $dir = $path;
  $dir =~ s/^${current_src}[\/\\\:]//s;
  $dir =~ s/([^\/\\\:]+)$//;
  my $filename = $1;


  my $f = "$current_src/$dir$filename";
  my $t = "$opt_out/$filename";
  $needs_compile->{$f} = {
          f => $f,
          t => $t,
          dir => $dir,
          filename => $filename
        };
}

# compile all the source files found by the wanted() sub, in sorted
# order so that the order of precedence makes sense.

sub compile_sorted {
  my ($sources) = @_;

  foreach my $f (sort keys %$sources) {
    my $entry = $needs_compile->{$f};
    my $t = $entry->{t};

    # TODO: dependency checking optimization?
    ## my $needs_rebuild = 0;
    ## if (!-f $t || -M $t > -M $f) {
    ## # the source file is newer, or dest is not there
    ## $needs_rebuild = 1;     
    ## }

    my $needs_rebuild = 1;

    if ($entry->{dir} =~ /sandbox/) {
      rule_file_compile_sandbox($f, $t, $entry->{filename});
    }
    elsif ($entry->{dir} =~ /extra/) {
      # 'extra' rulesets; not built by default (TODO)
      next;
    }
    else {
      # rules in "core" and "lang" are always copied
      if ($needs_rebuild) {
        rule_file_compile_core($f, $t, $entry->{filename});
      }
    }
  }
}

# implement the validation criteria from
# http://wiki.apache.org/spamassassin/RulesProjPromotion .
#
# Rules are compiled from source dir to output dir. All rules in "core" are
# always promoted (for backwards compatibility). In addition, rules in the
# sandboxes will be promoted, if the rules source file contains a "publish
# core" command prior to that rule.  This command is added (by hand!) to the
# source file by committers, as the rules pass the validation criteria.
#
# The compiler will copy the rules to the output directory. By default, the
# filename is preserved; so a rule in a file called "20_foo.cf" in the source
# directory will be output to the file "20_foo.cf".
#
# If the rule is not "publish"-tagged, it will be output as a testing rule
# to "70_sandbox.cf".
#
# Rules will be autorenamed, if there's a collision between a new rule name and
# one that's already been output by the compiler in another source file. The
# autorenaming is very simple -- portions of the current source path are
# appended to the rule name, sanitised.
#
# TODO: linting during compilation, and ignore lint-failures? may have to
# reimplement a small subset of lint behaviour to do this.

sub rule_file_compile_sandbox {
  my ($f, $t, $filename) = @_;

  open (IN, "<$f") or die "cannot read $f";

  # a fast parser for the config file format; don't need the
  # full deal here, and it must be fast, since it's run on every
  # "make" invocation

  my $rules = { };
  my $rule_order = [ ];

  # $COMMENTS is a "catch-all" "name", for lines that appear before the first
  # line that refers to a rule by name.  Those lines are not published by
  # themselves; they'll be published to all pubfiles found in the file.
  #
  # It's assumed they are comments, because they generally are, but could
  # be all sorts of unparseable lines.

  my $COMMENTS = '!comments!';
  my $lastrule = $COMMENTS;

  # another "fake name" for lines that should always be published, to an
  # output file with the same name as the input file.
  my $ALWAYS_PUBLISH = '!always_publish!';
  $rules->{$ALWAYS_PUBLISH} = { text => '', publish => 0 };

  # an "ifplugin" or "if" scope
  my $current_conditional;

  while (<IN>) {
    my $orig = $_;

    s/^#reuse/reuse/;   # TODO - dirty hack.  we need to fix this to just be
    # a keyword which the engine ignores, this is absurd! 

    s/#.*$//g; s/^\s+//; s/\s+$//;

    # send comments/blank lines to the current default output
    if (/^$/) {
      $rules->{$lastrule}->{text} .= $orig;
      next;
    }

    # save "lang" declarations
    my $lang = '';
    if (s/^lang\s+(\S+)\s+//) {
      $lang = $1;
    }

    if (/^
        (header|rawbody|body|full|uri|meta|mimeheader|describe|
        tflags|reuse|score)
        \s+(\S+)\s+(.*)$
      /x)
    {
      # rule definitions
      my $type = $1;
      my $name = $2;
      my $val = $3;

      my $origname = $name;
      $name = rule_name_avoid_collisions($name, $f);

      # TODO: sandbox rules -- enforce "T_" prefix

      if (!$rules->{$name}) { $rules->{$name} = rule_entry_create(); }
      $rules->{$name}->{origname} = $origname;
      $rules->{$name}->{cond} = $current_conditional;
      $rules->{$name}->{text} .= $orig;

      $lastrule = $name;
      push (@$rule_order, $name);
    }
    elsif (/^
        (pubfile|publish)
        \s+(\S+)\s*(.*?)$
      /x)
    {
      # preprocessor directives
      my $command = $1;
      my $name = $2;
      my $val = $3;

      my $origname = $name;
      $name = rule_name_avoid_collisions($name, $f);

      if (!$rules->{$name}) { $rules->{$name} = rule_entry_create(); }
      $rules->{$name}->{origname} = $origname;

      if ($command eq 'publish') {
        # the 'publish' command defaults to "1", unless it explicitly
        # is set to "0".  iow: publish RULE_NAME [(0 | 1)]  [default: 1]
        if (!defined $val) { $val = '1'; }
      }
      $rules->{$name}->{$command} = $val;
    }
    elsif (/^
        (if|ifplugin)
        \s+(.*?)$
      /x)
    {
      $current_conditional = $orig;
    }
    elsif (/^endif\b/x)
    {
      undef $current_conditional;
    }
    else {
      # warn "unknown line in rules file '$f', saving to default: $orig";
      $rules->{$ALWAYS_PUBLISH}->{text} .= $orig;
    }
  }
  close IN;

  # now append all the found text to the output file buffers
  my %already_done = ();
  my $copied = 0;
  foreach my $name ($ALWAYS_PUBLISH, @$rule_order)
  {
    # only do each rule once, please ;)
    next if exists $already_done{$name};
    $already_done{$name} = undef;

    my $pubfile;
    if ($rules->{$name}->{publish}) {
      $pubfile = ($rules->{$name}->{pubfile} || $filename);
      $pubfile = $opt_out.'/'.$pubfile;
    } else {
      $pubfile = $opt_sandboxout;
    }
    $output_files->{$pubfile} = 1;

    my $text = $rules->{$name}->{text};
    if (!$text) {
      next;     # nothing to write!
    }

    if (!$output_file_text->{$pubfile}) {
      $output_file_text->{$pubfile} = output_file_header($f);

      # do we have any top-of-file comments?  if so, add it
      my $cmts = $rules->{$COMMENTS}->{text}; $cmts ||= '';
      $output_file_text->{$pubfile} .= $cmts;
    }

    my $cond = $rules->{$name}->{cond};
    if ($cond) {
      $output_file_text->{$pubfile} .= $cond.$text."endif\n";
    }
    else {
      $output_file_text->{$pubfile} .= $text;
    }

    $copied++;
  }

  print "$f: $copied sandbox rules copied\n";

  # ok; file complete.  now mark all those rules as "seen"; future
  # refs to those rule names will trigger an autorename.
  foreach my $name (@$rule_order) {
    $seen_rules->{$name} = 1;
  }
}

sub rule_file_compile_core {
  my ($f, $t, $filename) = @_;

  my $pubfile = $opt_out.'/'.$filename;
  $output_files->{$pubfile} = 1;

  open (IN, "<$f") or die "cannot read $f";
  while (<IN>) {
    my $orig = $_;

    s/^#reuse/reuse/;   # TODO - dirty hack.  we need to fix this to just be
    # a keyword which the engine ignores, this is absurd! 

    s/#.*$//g; s/^\s+//; s/\s+$//;

    # always publish non-sandbox lines verbatim.  just note what
    # rules we've seen, and carry on
    $output_file_text->{$pubfile} .= $orig;

    # save "lang" declarations
    my $lang = '';
    if (s/^lang\s+(\S+)\s+//) {
      $lang = $1;
    }

    if (/^
        (header|rawbody|body|full|uri|meta|mimeheader|describe|
        tflags|reuse|score)
        \s+(\S+)\s+(.*)$
      /x)
    {
      # rule definitions
      my $type = $1;
      my $name = $2;
      my $val = $3;

      # just save the name, and ignore the rest; we're already publishing it
      $seen_rules->{$name} = 1;
    }
    elsif (/^
        (pubfile|publish)
        \s+(\S+)\s*(.*?)$
      /x)
    {
      # preprocessor directives
      my $command = $1;
      my $name = $2;
      my $val = $3;

      warn "$f: cannot use 'publish' in non-sandbox files\n";
    }
  }
  close IN;

  # now append all the found text to the output file buffers
  print "$f: all lines copied\n";
}

sub write_output_files {
  foreach my $pubfile (sort keys %$output_files) {
    if (-f $pubfile) {
      unlink $pubfile or die "cannot remove output file '$pubfile'";
    }

    if ($output_file_text->{$pubfile}) {
      open (OUT, ">".$pubfile) or die "cannot write to output file '$pubfile'";
      print OUT $output_file_text->{$pubfile};
      close OUT or die "cannot close output file '$pubfile'";
      print "$pubfile: written\n";
    }
    else {
      print "$pubfile: no rules promoted\n";
    }
  }
}

sub rule_entry_create {
  return {
    text => '',
    publish => 0
  };
}

sub rule_name_avoid_collisions {
  my ($rule, $path) = @_;
  if (!exists $seen_rules->{$rule}) {
    return $rule;
  }
  else {
    my $new = $path;
    $new =~ s/[^A-Za-z0-9]+/_/gs;
    $new =~ s/_+/_/gs;
    $new =~ s/^_//;
    $new =~ s/_$//;
    $new = $rule.'_'.$new;

    if (!$said_renamed_warning->{$new}) {
      $said_renamed_warning->{$new} = 1;
      warn "$rule: renamed to $new due to collision with existing rule\n";
    }

    return $new;
  }
}

sub output_file_header {
  my ($filename) = @_;
  my $now = scalar localtime time;
  return "# [compiled from '$filename' on $now]\n";
}

